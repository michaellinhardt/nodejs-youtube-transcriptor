# Implementation Plan: 11.0 - Data Structure Migration

**Version:** 2.0 (Reviewed)
**Original Date:** 2025-11-22
**Revision Date:** 2025-11-22
**Review Status:** REVIEWED_AND_ENHANCED
**Task:** 11.0 - Data Structure Migration (implements feature changes for registry format, file naming, and transcript structure)
**Status:** Ready for Implementation (Post-Review)
**Requirements:** FR-2.4, FR-2.5, FR-3.2, FR-6.1, FR-11, TR-23, TR-24, TR-27, TR-30, TR-31, TR-32, TR-33, BR-3

## Revision Notes

### Critical Issues Addressed
1. **CRITICAL: Registry Links Field Conflict** - Plan Step 4 removes links from ALLOWED_ENTRY_KEYS, but StorageService.js line 16 shows links still present. Migration must handle entries with links gracefully.
2. **CRITICAL: Date Format Validation Gap** - validators.js only accepts YYYY-MM-DD format. Must support YYMMDDTHHMM during migration to prevent validation failures.
3. **CRITICAL: Filename Migration Race Condition** - Plan lacks safeguards for concurrent file access during batch rename operations.
4. **SECURITY: Timestamp Injection Risk** - generateDateAdded uses client-side time without validation, allowing potential timestamp manipulation.
5. **BUG PREVENTION: Missing Rollback Mechanism** - Migration backup created but no automated rollback on validation failure.

### Major Enhancements
1. Added validation phase after migration before registry save
2. Introduced migration transaction boundaries with rollback support
3. Enhanced error handling with partial migration recovery
4. Added file lock mechanism for rename operations
5. Improved logging with migration audit trail
6. Added pre-migration validation checks
7. Enhanced backward compatibility with format detection

### Testing Improvements
- Added migration rollback test scenarios
- Enhanced edge case coverage (concurrent access, partial failures)
- Added performance benchmarks for large registry migration
- Included data integrity verification tests

### Code Quality Improvements
- Separated migration concerns into distinct phases
- Improved error messages with actionable recovery steps
- Added migration state tracking for resumability
- Enhanced validation with detailed failure reasons

## Plan Overview

This plan implements a comprehensive data structure migration affecting five core areas: date timestamp format (YYYY-MM-DD to YYMMDDTHHMM), channel formatting (apply same sanitization as title), transcript filename pattern (add transcript_ prefix), registry structure cleanup (remove links array), and transcript file markdown structure. The migration ensures backward compatibility through automatic data transformation while establishing the new format as the standard for future operations. This iteration establishes the final data model as specified in the updated technical requirements, with careful attention to migration safety, data integrity, and atomic operations throughout the transformation process.

**POST-REVIEW SECURITY ENHANCEMENTS:** Added timestamp validation, migration transaction boundaries, file locking during rename, and automated rollback on failure.

## Tasks Planned

- 11.0 Data Structure Migration (implements FR-3.2, FR-2.4, FR-2.5, FR-6.1, FR-11)
  - 11.1 Date format migration (YYYY-MM-DD to YYMMDDTHHMM)
  - 11.2 Channel formatting implementation (apply formatText to channel)
  - 11.3 Filename pattern updates (add transcript_ prefix)
  - 11.4 Registry structure cleanup (remove links field)
  - 11.5 Transcript file structure updates (new markdown format)
  - 11.6 Cleaning routine modifications (date matching with YYMMDD)
  - 11.7 Data migration and backward compatibility
  - 11.8 Testing and validation

## High-Level Steps

1. Update date generation and validation to YYMMDDTHHMM format
2. Apply channel formatting throughout the codebase
3. Add transcript_ prefix to all filename operations
4. Remove links field from registry schema and operations
5. Update transcript file structure to new markdown format
6. Modify cleaning routine date matching logic
7. Implement automatic data migration on registry load
8. Comprehensive testing across all scenarios

## Detailed Implementation

### Step 1: Date Format Migration (YYMMDDTHHMM)

#### A. Rationale & Objective

Current registry uses YYYY-MM-DD format (e.g., "2025-11-22") without time precision. New format YYMMDDTHHMM (e.g., "251122T1430") includes both date and time for precise temporal tracking while maintaining date-level cleanup operations. This change implements TR-31 and BR-3 specifications.

#### B. Core Concepts & Strategy

Replace all date generation with timestamp generation including hours and minutes. Update validation to accept new 11-character format (YYMMDDTHHMM pattern). Modify cleanup operations to extract and compare only YYMMDD prefix, ignoring THHMM portion. Migration converts existing YYYY-MM-DD dates to YYMMDDTHHMM format (preserving date, adding T0000 for midnight assumption).

```javascript
// Date format conversion strategy
YYYY-MM-DD (old) -> YYMMDDTHHMM (new)
"2025-11-22"     -> "251122T0000" (migration: midnight)
                 -> "251122T1430" (new entries: actual time)

// Validation patterns
OLD: /^\d{4}-\d{2}-\d{2}$/
NEW: /^\d{6}T\d{4}$/

// Cleanup matching (ignore time)
Input: "2025-11-22" -> convert to "251122" prefix
Entry: "251122T1430" -> extract "251122" prefix
Match: prefix comparison only
```

#### C. Implementation Guidelines

**Key Logic:**

```javascript
// src/utils/dateUtils.js (NEW FILE)

/**
 * Generate current timestamp in YYMMDDTHHMM format
 * Implements TR-31
 * SECURITY ENHANCEMENT: Validates generated timestamp before return
 */
function generateDateAdded() {
  const now = new Date();

  // SECURITY: Guard against invalid Date objects
  if (isNaN(now.getTime())) {
    throw new Error('Invalid Date object - system time may be corrupted');
  }

  const yy = String(now.getFullYear()).slice(-2); // Last 2 digits of year
  const mm = String(now.getMonth() + 1).padStart(2, '0');
  const dd = String(now.getDate()).padStart(2, '0');
  const hh = String(now.getHours()).padStart(2, '0');
  const min = String(now.getMinutes()).padStart(2, '0');

  const timestamp = `${yy}${mm}${dd}T${hh}${min}`;

  // SECURITY: Validate generated timestamp before returning
  if (!isValidTimestamp(timestamp)) {
    throw new Error(`Generated invalid timestamp: ${timestamp}`);
  }

  return timestamp;
  // Example output: "251122T1430"
}

/**
 * Validate YYMMDDTHHMM format
 * Implements TR-31 validation
 * BUG FIX: Added year range validation and enhanced edge case handling
 */
function isValidTimestamp(timestamp) {
  if (typeof timestamp !== 'string') return false;

  // BUG FIX: Explicitly check length before regex to prevent ReDoS
  if (timestamp.length !== 11) return false;

  const match = /^(\d{2})(\d{2})(\d{2})T(\d{2})(\d{2})$/.exec(timestamp);
  if (!match) return false;

  const [_, yy, mm, dd, hh, min] = match;

  // Validate ranges
  const yearNum = parseInt(yy, 10);
  const monthNum = parseInt(mm, 10);
  const dayNum = parseInt(dd, 10);
  const hourNum = parseInt(hh, 10);
  const minNum = parseInt(min, 10);

  // BUG FIX: Validate year range (00-99, assuming 2000-2099)
  if (yearNum < 0 || yearNum > 99) return false;

  if (monthNum < 1 || monthNum > 12) return false;
  if (dayNum < 1 || dayNum > 31) return false;
  if (hourNum > 23) return false;
  if (minNum > 59) return false;

  // Validate actual calendar date
  const fullYear = 2000 + yearNum;
  const date = new Date(fullYear, monthNum - 1, dayNum, hourNum, minNum);

  // BUG FIX: Check Date object is valid before accessing methods
  if (isNaN(date.getTime())) return false;

  return date.getMonth() === monthNum - 1 && date.getDate() === dayNum;
}

/**
 * Convert YYYY-MM-DD to YYMMDD prefix for cleanup matching
 * Implements TR-30
 */
function convertDateToPrefix(dateString) {
  // Validate input format first
  if (!/^\d{4}-\d{2}-\d{2}$/.test(dateString)) {
    throw new Error(`Invalid date format: ${dateString}`);
  }

  const year = dateString.substring(2, 4); // YY
  const month = dateString.substring(5, 7); // MM
  const day = dateString.substring(8, 10); // DD

  return `${year}${month}${day}`;
  // Input: "2025-11-22" -> Output: "251122"
}

/**
 * Extract date prefix from timestamp for comparison
 * Implements TR-32
 */
function extractDatePrefix(timestamp) {
  // Extract YYMMDD from YYMMDDTHHMM
  return timestamp.substring(0, 6);
  // Input: "251122T1430" -> Output: "251122"
}

/**
 * Migrate old date format to new timestamp format
 * Used during registry migration
 */
function migrateDate(oldDate) {
  // YYYY-MM-DD -> YYMMDDTHHMM (assume midnight)
  if (!/^\d{4}-\d{2}-\d{2}$/.test(oldDate)) {
    throw new Error(`Cannot migrate invalid date: ${oldDate}`);
  }

  const yy = oldDate.substring(2, 4);
  const mm = oldDate.substring(5, 7);
  const dd = oldDate.substring(8, 10);

  return `${yy}${mm}${dd}T0000`;
  // Input: "2025-11-22" -> Output: "251122T0000"
}
```

**Critical Points:**

- Date generation uses current time (not hardcoded midnight)
- **SECURITY**: Generated timestamp validated before return to prevent corruption
- **BUG FIX**: Timestamp length checked before regex to prevent ReDoS attacks
- Validation checks calendar validity (prevent Feb 31, etc.)
- **BUG FIX**: Date object validity checked before method access
- Cleanup conversion preserves user input format (YYYY-MM-DD)
- Prefix extraction ignores time portion completely
- Migration assumes midnight (T0000) for historical entries
- **ENHANCEMENT**: Year range validation (2000-2099) prevents century overflow

#### D. Success Criteria

- [ ] generateDateAdded returns YYMMDDTHHMM format with current time
- [ ] isValidTimestamp rejects YYYY-MM-DD format
- [ ] isValidTimestamp accepts YYMMDDTHHMM format
- [ ] convertDateToPrefix converts YYYY-MM-DD to YYMMDD correctly
- [ ] extractDatePrefix returns first 6 characters only
- [ ] migrateDate converts old format to new with T0000

#### E. Dependencies & Inputs

- Requires: New src/utils/dateUtils.js utility module
- Produces: Date generation and validation functions for all services
- Impacts: StorageService, validators.js, clean.js command

---

### Step 2: Channel Formatting Implementation

#### A. Rationale & Objective

Currently only video titles are formatted for filesystem safety. Channels must receive identical sanitization treatment per FR-2.5 and TR-26. Both fields are stored in formatted versions in the registry and displayed in formatted versions in transcript files for consistency.

#### B. Core Concepts & Strategy

Apply existing MetadataService.formatTitle() method to channel names. Store formatted channel in registry. Display formatted channel in transcript file headers. No changes to formatting algorithm needed—use same sanitization for both title and channel.

```javascript
// Formatting strategy (same for title AND channel)
Original -> Formatted
"TechLinked Channel" -> "techlinked_channel"
"John's Tech Blog!" -> "johns_tech_blog"
"C++ Weekly" -> "c_weekly"

// Both stored formatted in registry:
{
  "videoId": {
    "date_added": "251122T1430",
    "channel": "techlinked_channel", // FORMATTED
    "title": "how_to_build_rest_apis" // FORMATTED
  }
}

// Both displayed formatted in transcript:
Channel: techlinked_channel
Title: how_to_build_rest_apis
```

#### C. Implementation Guidelines

**Key Logic:**

```javascript
// src/services/MetadataService.js (MODIFY EXISTING)

/**
 * Format channel name for filesystem safety
 * Uses same algorithm as formatTitle per FR-2.5
 * BUG FIX: Added null/undefined guard and empty string validation
 */
formatChannel(channel) {
  // BUG FIX: Guard against null/undefined inputs
  if (!channel || typeof channel !== 'string') {
    console.warn('[MetadataService] Invalid channel input for formatting');
    return 'unknown_channel';
  }

  // Reuse formatTitle implementation (identical sanitization)
  const formatted = this.formatTitle(channel);

  // BUG FIX: Ensure non-empty result (formatTitle may return empty string)
  if (!formatted || formatted.trim() === '') {
    return 'unknown_channel';
  }

  return formatted;
}

// Update fetchVideoMetadata to format BOTH fields:
async fetchVideoMetadata(videoId) {
  // ... fetch logic ...

  const channel = response.data.author_name?.trim() || this.FALLBACK_CHANNEL;
  const title = response.data.title?.trim() || this.FALLBACK_TITLE;

  const validatedMetadata = this.validateMetadata({ channel, title });

  // CRITICAL: Format BOTH before returning
  return {
    channel: this.formatChannel(validatedMetadata.channel),
    title: this.formatTitle(validatedMetadata.title)
  };
}

// src/services/StorageService.js (MODIFY EXISTING)

/**
 * Build metadata header with formatted values
 */
buildMetadataHeader(metadata, videoId) {
  const { channel, title } = metadata;

  // Validate inputs
  if (!channel || !title || !videoId) {
    throw new Error('All metadata fields required for header generation');
  }

  // Build short URL
  const MetadataService = require('./MetadataService');
  const metadataService = new MetadataService();
  const shortUrl = metadataService.buildShortUrl(videoId);

  // MODIFIED: Use formatted values directly (no re-formatting)
  const header = [
    `# Transcript`,
    ``,
    `## Information`,
    ``,
    `Channel: ${channel}`, // Already formatted
    `Title: ${title}`,     // Already formatted
    `Youtube ID: ${videoId}`,
    `URL: ${shortUrl}`,
    ``,
    `## Content`,
    ``,
  ].join('\n');

  return header;
}
```

**Critical Points:**

- Channel formatting uses identical algorithm to title formatting
- **BUG FIX**: Null/undefined inputs return fallback value instead of throwing
- **BUG FIX**: Empty string after formatting returns fallback (prevents blank channel names)
- Both fields formatted BEFORE storage (registry and file)
- Transcript header displays formatted versions (not original)
- Fallback values also get formatted ("Unknown Channel" -> "unknown_channel")
- No special handling needed—consistent sanitization throughout
- **ENHANCEMENT**: Logging added for debugging invalid channel inputs

#### D. Success Criteria

- [ ] formatChannel method added to MetadataService
- [ ] fetchVideoMetadata returns formatted channel
- [ ] Registry stores formatted channel (validated in isValidEntryStructure)
- [ ] buildMetadataHeader uses formatted channel directly
- [ ] Transcript files display formatted channel in Information section
- [ ] Fallback channel values are formatted ("unknown_channel")

#### E. Dependencies & Inputs

- Requires: MetadataService.formatTitle (existing)
- Produces: Formatted channel field in metadata objects
- Impacts: MetadataService, StorageService, registry validation

---

### Step 3: Filename Pattern Updates (transcript_ prefix)

#### A. Rationale & Objective

Current pattern: `{videoId}_{formattedTitle}.md` or `{videoId}.md`
New pattern: `transcript_{videoId}_{formattedTitle}.md` or `transcript_{videoId}.md`

Adding "transcript_" prefix improves file organization and distinguishes transcript files from other markdown files in storage directories. Implements FR-2.4 and TR-23 specifications.

#### B. Core Concepts & Strategy

Update all filename generation to prepend "transcript_" prefix. Modify file search operations to look for both old and new patterns (backward compatibility). Update symbolic link creation to use new pattern. Migration renames existing files during first load.

```javascript
// Filename pattern transformation
OLD: {videoId}_{formattedTitle}.md
NEW: transcript_{videoId}_{formattedTitle}.md

Examples:
OLD: "dQw4w9WgXcQ_never_gonna_give_you_up.md"
NEW: "transcript_dQw4w9WgXcQ_never_gonna_give_you_up.md"

OLD: "dQw4w9WgXcQ.md" (no metadata)
NEW: "transcript_dQw4w9WgXcQ.md"

// File search pattern (supports both during migration)
Pattern: transcript_{videoId}_*.md OR transcript_{videoId}.md (new)
Fallback: {videoId}_*.md OR {videoId}.md (old)
```

#### C. Implementation Guidelines

**Key Logic:**

```javascript
// src/services/StorageService.js (MODIFY EXISTING)

/**
 * Build filename with transcript_ prefix
 * MODIFIED to implement TR-23
 */
async buildFilename(videoId, metadata) {
  // Backward compatibility check for old format
  if (!metadata || !metadata.title) {
    return `transcript_${videoId}.md`; // CHANGED: add prefix
  }

  // Format title for filesystem safety
  const MetadataService = require('./MetadataService');
  const metadataService = new MetadataService();
  const formattedTitle = metadataService.formatTitle(metadata.title);

  // CHANGED: Add prefix to filename
  let filename = `transcript_${videoId}_${formattedTitle}.md`;

  // Validate length (255 char limit)
  if (filename.length > 255) {
    // Truncate: prefix (11) + videoId (11) + _ (1) + title + .md (3) = 26 fixed
    const maxTitleLength = 255 - 26;
    const truncatedTitle = formattedTitle.substring(0, maxTitleLength);
    filename = `transcript_${videoId}_${truncatedTitle}.md`;
  }

  // Collision detection unchanged (checks Youtube ID in file content)
  // ...existing collision logic...

  return filename;
}

/**
 * Get transcript file path (searches both old and new patterns)
 * MODIFIED for backward compatibility
 */
async getTranscriptPath(videoId) {
  const transcriptsPath = this.paths.getTranscriptsPath();

  try {
    const files = await fs.readdir(transcriptsPath);

    // PRIORITY 1: Search for NEW pattern first
    let match = files.find(file =>
      (file.startsWith(`transcript_${videoId}_`) && file.endsWith('.md')) ||
      file === `transcript_${videoId}.md`
    );

    // PRIORITY 2: Fallback to OLD pattern for backward compatibility
    if (!match) {
      match = files.find(file =>
        (file.startsWith(`${videoId}_`) && file.endsWith('.md')) ||
        file === `${videoId}.md`
      );
    }

    return match ? path.join(transcriptsPath, match) : null;
  } catch (error) {
    console.warn(`Error finding transcript for ${videoId}: ${error.message}`);
    return null;
  }
}

// src/services/LinkManager.js (MODIFY EXISTING)

/**
 * Create symbolic link with new filename pattern
 * MODIFIED to use transcript_ prefix
 */
async createLink(videoId, metadata) {
  const storage = this.storage;

  // Build source path (central storage) with NEW pattern
  const sourceFilename = await storage.buildFilename(videoId, metadata);
  const sourcePath = path.join(this.paths.getTranscriptsPath(), sourceFilename);

  // Build target path (project directory) with SAME pattern
  const targetPath = path.join(this.paths.getLocalTranscriptsPath(), sourceFilename);

  // ... rest of link creation logic unchanged ...
}
```

**Critical Points:**

- All new files created with transcript_ prefix
- File search checks new pattern first, then falls back to old
- Symbolic links use same filename as source (consistency)
- Migration renames old files to new pattern (Step 7)
- Length validation accounts for prefix (11 extra characters)
- **BUG PREVENTION**: getTranscriptPath catches ENOENT errors during directory read
- **ENHANCEMENT**: Pattern matching uses strict startsWith to prevent partial matches
- **SECURITY**: Filename validation prevents directory traversal in generated names

#### D. Success Criteria

- [ ] buildFilename returns names starting with "transcript_"
- [ ] getTranscriptPath finds files with new pattern
- [ ] getTranscriptPath falls back to old pattern (migration support)
- [ ] New transcripts created with prefix in both locations
- [ ] Symbolic links created with prefix pattern
- [ ] Filename length validation accounts for prefix

#### E. Dependencies & Inputs

- Requires: StorageService.buildFilename modification
- Produces: New filename pattern for all file operations
- Impacts: StorageService, LinkManager, file search operations

---

### Step 4: Registry Structure Cleanup (remove links)

#### A. Rationale & Objective

Registry currently tracks symbolic link paths in a "links" array per entry. This field is no longer used operationally and adds complexity to registry validation. Removal simplifies schema to core metadata only: date_added, channel, title. Implements FR-3.2 and TR-24.

#### B. Core Concepts & Strategy

Remove "links" from ALLOWED_ENTRY_KEYS constant. Update validation to reject entries containing links field. Remove all code that reads/writes links arrays. Migration deletes links field from existing entries. Ensure no operational breakage (link creation/deletion already independent of registry tracking).

```javascript
// Registry schema transformation
OLD:
{
  "dQw4w9WgXcQ": {
    "date_added": "2025-11-22",
    "channel": "rick_astley",
    "title": "never_gonna_give_you_up",
    "links": ["/path/to/project1/transcripts/...", "/path/to/project2/..."]
  }
}

NEW:
{
  "dQw4w9WgXcQ": {
    "date_added": "251122T1430",
    "channel": "rick_astley",
    "title": "never_gonna_give_you_up"
    // NO links field
  }
}
```

#### C. Implementation Guidelines

**Key Logic:**

```javascript
// src/services/StorageService.js (MODIFY EXISTING)

class StorageService {
  // CHANGE: Remove 'links' from allowed keys
  static ALLOWED_ENTRY_KEYS = ['date_added', 'channel', 'title'];

  /**
   * Validate entry structure
   * MODIFIED to reject links field
   */
  isValidEntryStructure(entry) {
    if (!this.isPlainObject(entry)) {
      return false;
    }

    // CRITICAL: date_added is required string
    if (!entry.date_added || typeof entry.date_added !== 'string') {
      return false;
    }

    // REMOVED: links array validation (no longer allowed)

    // Channel optional but must be non-empty string if present
    if (entry.channel !== undefined) {
      if (typeof entry.channel !== 'string' || entry.channel.trim() === '') {
        return false;
      }
      if (entry.channel.length > 200) {
        console.warn(`Channel name exceeds 200 chars`);
        return false;
      }
    }

    // Title optional but must be non-empty string if present
    if (entry.title !== undefined) {
      if (typeof entry.title !== 'string' || entry.title.trim() === '') {
        return false;
      }
      if (entry.title.length > 500) {
        console.warn(`Title exceeds 500 chars`);
        return false;
      }
    }

    return true;
  }

  // REMOVE: areLinksValid method (no longer needed)
  // REMOVE: All references to entry.links in isValidEntry
}

// src/utils/validators.js (MODIFY EXISTING)

/**
 * Update date validation to accept new timestamp format
 * MODIFY existing isValidDate function
 * CRITICAL: Must support both formats during migration period
 */
function isValidDate(dateString) {
  if (typeof dateString !== 'string') {
    return false;
  }

  // BUG FIX: Check length first to prevent unnecessary regex execution
  if (dateString.length !== 10 && dateString.length !== 11) {
    return false;
  }

  // NEW: Accept YYMMDDTHHMM format (length 11)
  if (dateString.length === 11) {
    const timestampMatch = /^(\d{2})(\d{2})(\d{2})T(\d{2})(\d{2})$/.exec(dateString);
    if (timestampMatch) {
      // Delegate to dateUtils for timestamp validation
      const dateUtils = require('./dateUtils');
      return dateUtils.isValidTimestamp(dateString);
    }
    return false; // Length 11 but doesn't match timestamp pattern
  }

  // OLD: Accept YYYY-MM-DD for backward compatibility during migration (length 10)
  const legacyMatch = /^(\d{4})-(\d{2})-(\d{2})$/.exec(dateString);
  if (legacyMatch) {
    // Extract and validate components
    const year = parseInt(legacyMatch[1], 10);
    const month = parseInt(legacyMatch[2], 10);
    const day = parseInt(legacyMatch[3], 10);

    // Validate ranges
    if (year < 2000 || year > 2099) return false;
    if (month < 1 || month > 12) return false;
    if (day < 1 || day > 31) return false;

    // Validate actual calendar date
    const date = new Date(year, month - 1, day);
    if (isNaN(date.getTime())) return false;

    return date.getMonth() === month - 1 && date.getDate() === day;
  }

  return false;
}

/**
 * Assert valid date with detailed error message
 * ENHANCEMENT: Added for better error reporting
 */
function assertValidDate(dateString, context = 'date') {
  if (!isValidDate(dateString)) {
    throw new Error(
      `Invalid ${context} format: "${dateString}". ` +
      `Expected YYMMDDTHHMM (e.g., "251122T1430") or YYYY-MM-DD (legacy)`
    );
  }
}
```

**Critical Points:**

- ALLOWED_ENTRY_KEYS no longer includes "links"
- Validation rejects any entry containing links field
- Migration removes links from all entries (Step 7)
- Link operations already independent (LinkManager doesn't use registry tracking)
- Simplified schema reduces validation complexity

#### D. Success Criteria

- [ ] ALLOWED_ENTRY_KEYS = ['date_added', 'channel', 'title']
- [ ] isValidEntryStructure no longer validates links array
- [ ] areLinksValid method removed
- [ ] hasOnlyAllowedKeys rejects entries with links field
- [ ] No code references entry.links after cleanup
- [ ] Registry save operations exclude links field

#### E. Dependencies & Inputs

- Requires: StorageService schema update
- Produces: Simplified registry structure
- Impacts: Registry validation, migration logic

---

### Step 5: Transcript File Structure Updates

#### A. Rationale & Objective

Transform transcript files from flat metadata format to structured markdown with sections. New structure improves readability and follows markdown best practices. Implements FR-11 and TR-27 specifications.

#### B. Core Concepts & Strategy

Update buildMetadataHeader to generate markdown structure with "# Transcript" title, "## Information" section for metadata, and "## Content" section for transcript text. Use formatted channel and title (already formatted in previous steps). Maintain standardized short URL format.

```markdown
# OLD FORMAT (flat metadata)
Channel: TechLinked Channel
Title: How to Build REST APIs
Youtube ID: dQw4w9WgXcQ
URL: https://youtu.be/dQw4w9WgXcQ

[transcript text]

# NEW FORMAT (structured markdown)
# Transcript

## Information

Channel: techlinked_channel
Title: how_to_build_rest_apis
Youtube ID: dQw4w9WgXcQ
URL: https://youtu.be/dQw4w9WgXcQ

## Content

[transcript text]
```

#### C. Implementation Guidelines

**Key Logic:**

```javascript
// src/services/StorageService.js (ALREADY UPDATED IN STEP 2)

/**
 * Build metadata header with new markdown structure
 * Implements FR-11, TR-27
 */
buildMetadataHeader(metadata, videoId) {
  const { channel, title } = metadata;

  // Validate inputs
  if (!channel || !title || !videoId) {
    throw new Error('All metadata fields required for header generation');
  }

  // Build short URL with validation
  const MetadataService = require('./MetadataService');
  const metadataService = new MetadataService();
  const shortUrl = metadataService.buildShortUrl(videoId);

  // MODIFIED: New markdown structure per FR-11.1
  const header = [
    `# Transcript`,          // Main title
    ``,                      // Blank line
    `## Information`,        // Metadata section
    ``,                      // Blank line
    `Channel: ${channel}`,   // Formatted channel
    `Title: ${title}`,       // Formatted title
    `Youtube ID: ${videoId}`,
    `URL: ${shortUrl}`,
    ``,                      // Blank line
    `## Content`,            // Content section
    ``,                      // Blank line
  ].join('\n');

  return header;
}

// No changes to saveTranscript needed - already uses buildMetadataHeader
```

**Critical Points:**

- Markdown structure: H1 for file, H2 for sections
- Blank lines between sections for readability
- Channel and title already formatted (from Step 2)
- Content section separator clearly marks transcript start
- Header function already integrated in saveTranscript

#### D. Success Criteria

- [ ] buildMetadataHeader returns structured markdown
- [ ] First line is "# Transcript"
- [ ] Metadata under "## Information" section
- [ ] Transcript text under "## Content" section
- [ ] Blank lines properly placed
- [ ] Formatted channel and title displayed correctly

#### E. Dependencies & Inputs

- Requires: Step 2 (channel formatting) completed
- Produces: Structured markdown transcript files
- Impacts: StorageService.buildMetadataHeader only

---

### Step 6: Cleaning Routine Modifications

#### A. Rationale & Objective

Cleaning command currently compares date_added (YYYY-MM-DD) directly to user input. New format requires extracting YYMMDD prefix from YYMMDDTHHMM timestamp and converting user input from YYYY-MM-DD to YYMMDD for comparison. Time portion (THHMM) must be ignored. Implements FR-6.1, TR-30, TR-32, TR-33.

#### B. Core Concepts & Strategy

Convert user input (YYYY-MM-DD) to YYMMDD prefix using convertDateToPrefix. Extract YYMMDD prefix from registry timestamps using extractDatePrefix. Compare prefixes only (string comparison works lexicographically). Maintain exclusive boundary logic (dates before input, not equal).

```javascript
// Cleanup date matching strategy
User input: "2025-11-22"
Convert to: "251122" (prefix)

Registry entries:
"251121T1430" -> extract "251121" -> 251121 < 251122 -> DELETE
"251122T0900" -> extract "251122" -> 251122 == 251122 -> KEEP (boundary excluded)
"251122T2359" -> extract "251122" -> 251122 == 251122 -> KEEP
"251123T0000" -> extract "251123" -> 251123 > 251122 -> KEEP

Comparison logic:
datePrefix < convertedInput -> DELETE
datePrefix >= convertedInput -> KEEP
```

#### C. Implementation Guidelines

**Key Logic:**

```javascript
// src/commands/clean.js (MODIFY EXISTING)

const dateUtils = require('../utils/dateUtils');

/**
 * Validate registry entry for cleanup filtering
 * MODIFIED to support new timestamp format
 */
function validateRegistryEntry(videoId, entry) {
  if (!entry || typeof entry !== 'object') {
    return { valid: false, reason: 'Entry is null or not an object' };
  }

  if (!entry.date_added || typeof entry.date_added !== 'string' || entry.date_added.trim() === '') {
    return { valid: false, reason: 'Missing or invalid date_added field' };
  }

  // MODIFIED: Accept both YYMMDDTHHMM and YYYY-MM-DD (migration support)
  if (!validators.isValidDate(entry.date_added)) {
    return { valid: false, reason: `Invalid date format: ${entry.date_added}` };
  }

  // REMOVED: links field validation (no longer in schema)

  return { valid: true };
}

/**
 * Clean command handler
 * MODIFIED to handle new timestamp format
 */
async function cleanCommand(dateString) {
  // ... validation and setup unchanged ...

  // STEP 2.5: Convert user input to YYMMDD prefix for comparison
  let boundaryPrefix;
  try {
    boundaryPrefix = dateUtils.convertDateToPrefix(dateString);
  } catch (error) {
    console.error('Date conversion failed:', error.message);
    process.exit(2);
  }

  console.log(`Cleaning transcripts older than ${dateString} (prefix: ${boundaryPrefix})`);

  // Filter transcripts by date prefix (exclusive boundary)
  const deletionCandidates = [];
  let skippedCount = 0;
  let corruptedCount = 0;

  for (const [videoId, entry] of Object.entries(registry)) {
    // Validate entry structure
    const validationResult = validateRegistryEntry(videoId, entry);
    if (!validationResult.valid) {
      console.warn(`Skipping corrupted entry: ${videoId} - ${validationResult.reason}`);
      corruptedCount++;
      continue;
    }

    // MODIFIED: Extract date prefix from timestamp and compare
    let entryPrefix;

    // Check if new format (YYMMDDTHHMM)
    if (/^\d{6}T\d{4}$/.test(entry.date_added)) {
      entryPrefix = dateUtils.extractDatePrefix(entry.date_added);
    }
    // Fallback to old format (YYYY-MM-DD) during migration
    else if (/^\d{4}-\d{2}-\d{2}$/.test(entry.date_added)) {
      entryPrefix = dateUtils.convertDateToPrefix(entry.date_added);
    }
    else {
      console.warn(`Skipping entry with unrecognized date format: ${videoId}`);
      corruptedCount++;
      continue;
    }

    // Compare prefixes (lexicographic comparison works for YYMMDD)
    if (entryPrefix < boundaryPrefix) {
      deletionCandidates.push({ videoId, entry });
    } else {
      skippedCount++;
    }
  }

  // ... rest of cleanup logic unchanged ...
  // Delete transcript files (already supports both old and new patterns via getTranscriptPath)
  // Remove registry entries (no links field cleanup needed anymore)
}

module.exports = cleanCommand;
```

**Critical Points:**

- Input remains YYYY-MM-DD for user convenience
- Convert input to YYMMDD prefix for comparison
- Extract YYMMDD from timestamps, ignore THHMM
- Support both formats during migration period
- Lexicographic comparison works (251121 < 251122 < 251123)
- Boundary date excluded (< not <=)

#### D. Success Criteria

- [ ] convertDateToPrefix converts YYYY-MM-DD to YYMMDD
- [ ] extractDatePrefix extracts first 6 chars from timestamp
- [ ] Cleanup correctly identifies older transcripts
- [ ] Boundary date excluded from deletion
- [ ] Time portion (THHMM) completely ignored
- [ ] Both old and new formats supported during migration

#### E. Dependencies & Inputs

- Requires: dateUtils.convertDateToPrefix, dateUtils.extractDatePrefix
- Produces: Correct deletion filtering with new format
- Impacts: clean.js command only

---

### Step 7: Data Migration and Backward Compatibility

#### A. Rationale & Objective

Existing installations have data.json with old format (YYYY-MM-DD dates, links arrays, old filenames). Migration must automatically transform existing data to new format on first load while preserving data integrity and maintaining backward compatibility during transition. Critical for seamless upgrades without manual intervention.

#### B. Core Concepts & Strategy

Detect old format entries during registry load. Transform in-place: convert dates, remove links, rename files. Create backup before migration. Log all migration actions for audit trail. Support mixed old/new format during migration period. Atomic operations ensure no data loss on failure.

```javascript
// Migration detection strategy
Entry format indicators:
- OLD date: /^\d{4}-\d{2}-\d{2}$/
- NEW date: /^\d{6}T\d{4}$/
- OLD has: "links" field present
- NEW has: no "links" field

Migration workflow:
1. Backup data.json to data.json.backup.YYMMDDTHHMM
2. Load registry
3. For each entry:
   - If old date format: convert to YYMMDDTHHMM
   - If has links field: delete it
   - Validate converted entry
4. Rename files: {videoId}_*.md -> transcript_{videoId}_*.md
5. Save migrated registry atomically
6. Log migration summary
```

#### C. Implementation Guidelines

**Key Logic:**

```javascript
// src/services/MigrationService.js (NEW FILE)

const fs = require('fs-extra');
const path = require('path');
const dateUtils = require('../utils/dateUtils');

class MigrationService {
  constructor(storage, paths) {
    this.storage = storage;
    this.paths = paths;
  }

  /**
   * Check if registry needs migration
   * Returns true if any entry has old format
   */
  needsMigration(registry) {
    for (const [videoId, entry] of Object.entries(registry)) {
      // Check for old date format
      if (/^\d{4}-\d{2}-\d{2}$/.test(entry.date_added)) {
        return true;
      }
      // Check for links field
      if (entry.links !== undefined) {
        return true;
      }
    }
    return false;
  }

  /**
   * Migrate registry to new format
   * Returns migrated registry object
   */
  async migrateRegistry(registry) {
    console.log('\n=== Data Migration Starting ===\n');
    console.log('Migrating registry to new format...');

    const stats = {
      total: Object.keys(registry).length,
      datesConverted: 0,
      linksRemoved: 0,
      filesRenamed: 0,
      errors: []
    };

    const migratedRegistry = {};

    for (const [videoId, entry] of Object.entries(registry)) {
      try {
        const migratedEntry = await this.migrateEntry(videoId, entry, stats);
        migratedRegistry[videoId] = migratedEntry;
      } catch (error) {
        console.error(`Migration failed for ${videoId}: ${error.message}`);
        stats.errors.push({ videoId, error: error.message });
        // Keep original entry on migration failure
        migratedRegistry[videoId] = entry;
      }
    }

    // Rename transcript files
    await this.renameTranscriptFiles(registry, stats);

    console.log('\n=== Migration Summary ===');
    console.log(`Total entries: ${stats.total}`);
    console.log(`Dates converted: ${stats.datesConverted}`);
    console.log(`Links fields removed: ${stats.linksRemoved}`);
    console.log(`Files renamed: ${stats.filesRenamed}`);
    console.log(`Errors: ${stats.errors.length}`);

    if (stats.errors.length > 0) {
      console.warn('\nMigration errors:');
      stats.errors.forEach(err => {
        console.warn(`  ${err.videoId}: ${err.error}`);
      });
    }

    console.log('\n=== Migration Complete ===\n');

    return migratedRegistry;
  }

  /**
   * Migrate single registry entry
   */
  async migrateEntry(videoId, entry, stats) {
    const migrated = { ...entry };

    // Convert date format if needed
    if (/^\d{4}-\d{2}-\d{2}$/.test(entry.date_added)) {
      migrated.date_added = dateUtils.migrateDate(entry.date_added);
      stats.datesConverted++;
      console.log(`  ${videoId}: Date converted to ${migrated.date_added}`);
    }

    // Remove links field if present
    if (migrated.links !== undefined) {
      delete migrated.links;
      stats.linksRemoved++;
      console.log(`  ${videoId}: Links field removed`);
    }

    // Ensure channel and title exist (backward compatibility)
    if (!migrated.channel) {
      migrated.channel = 'unknown_channel';
      console.warn(`  ${videoId}: Added fallback channel`);
    }
    if (!migrated.title) {
      migrated.title = 'unknown_title';
      console.warn(`  ${videoId}: Added fallback title`);
    }

    return migrated;
  }

  /**
   * Rename transcript files from old to new pattern
   * CRITICAL FIX: Added file locking and transaction boundaries
   */
  async renameTranscriptFiles(registry, stats) {
    const transcriptsPath = this.paths.getTranscriptsPath();
    const lockFilePath = path.join(transcriptsPath, '.migration.lock');
    const renameLog = [];

    try {
      // CRITICAL: Create lock file to prevent concurrent access
      if (await fs.pathExists(lockFilePath)) {
        throw new Error('Migration already in progress (lock file exists)');
      }
      await fs.writeFile(lockFilePath, JSON.stringify({
        startTime: new Date().toISOString(),
        pid: process.pid
      }), 'utf8');

      const files = await fs.readdir(transcriptsPath);

      for (const file of files) {
        // Skip lock file and files with transcript_ prefix
        if (file === '.migration.lock' || file.startsWith('transcript_')) {
          continue;
        }

        // Check if file matches old pattern
        const videoIdMatch = /^([A-Za-z0-9_-]{11})(_.*)?\.md$/.exec(file);
        if (!videoIdMatch) {
          continue;
        }

        const videoId = videoIdMatch[1];

        // Verify video ID exists in registry
        if (!registry[videoId]) {
          console.warn(`  Skipping orphan file: ${file}`);
          continue;
        }

        // Rename: add transcript_ prefix
        const oldPath = path.join(transcriptsPath, file);
        const newFile = `transcript_${file}`;
        const newPath = path.join(transcriptsPath, newFile);

        // Check if target already exists
        if (await fs.pathExists(newPath)) {
          console.warn(`  Target exists, skipping: ${newFile}`);
          continue;
        }

        // CRITICAL: Validate paths before rename (prevent traversal)
        if (!oldPath.startsWith(transcriptsPath) || !newPath.startsWith(transcriptsPath)) {
          throw new Error(`Path traversal attempt detected: ${file}`);
        }

        // ENHANCEMENT: Log rename operation for rollback capability
        renameLog.push({ oldPath, newPath, videoId });

        await fs.rename(oldPath, newPath);
        stats.filesRenamed++;
        console.log(`  Renamed: ${file} -> ${newFile}`);
      }

      // ENHANCEMENT: Save rename log for audit trail
      if (renameLog.length > 0) {
        const logPath = path.join(transcriptsPath, '.rename.log');
        await fs.writeJson(logPath, {
          timestamp: new Date().toISOString(),
          operations: renameLog
        }, { spaces: 2 });
      }

    } catch (error) {
      console.error(`File rename error: ${error.message}`);
      stats.errors.push({ file: 'batch rename', error: error.message });

      // CRITICAL: Rollback on error
      if (renameLog.length > 0) {
        console.warn('Rolling back file renames...');
        for (const { oldPath, newPath } of renameLog.reverse()) {
          try {
            if (await fs.pathExists(newPath)) {
              await fs.rename(newPath, oldPath);
              console.log(`  Rolled back: ${path.basename(newPath)}`);
            }
          } catch (rollbackError) {
            console.error(`  Rollback failed for ${path.basename(newPath)}: ${rollbackError.message}`);
          }
        }
      }

      throw error; // Re-throw to fail migration
    } finally {
      // CRITICAL: Always remove lock file
      try {
        await fs.remove(lockFilePath);
      } catch (unlockError) {
        console.error(`Failed to remove lock file: ${unlockError.message}`);
      }
    }
  }

  /**
   * Validate migrated registry before saving
   * CRITICAL ADDITION: Prevents saving corrupted data
   */
  validateMigratedRegistry(registry) {
    const errors = [];
    const dateUtils = require('../utils/dateUtils');

    for (const [videoId, entry] of Object.entries(registry)) {
      // Validate video ID format
      if (!/^[A-Za-z0-9_-]{11}$/.test(videoId)) {
        errors.push(`${videoId}: Invalid video ID format`);
        continue;
      }

      // Validate entry structure
      if (!entry || typeof entry !== 'object') {
        errors.push(`${videoId}: Entry is not an object`);
        continue;
      }

      // CRITICAL: Validate new timestamp format
      if (!entry.date_added || !dateUtils.isValidTimestamp(entry.date_added)) {
        errors.push(`${videoId}: Invalid timestamp format - ${entry.date_added}`);
      }

      // CRITICAL: Validate channel field
      if (!entry.channel || typeof entry.channel !== 'string' || entry.channel.trim() === '') {
        errors.push(`${videoId}: Missing or invalid channel field`);
      }

      // CRITICAL: Validate title field
      if (!entry.title || typeof entry.title !== 'string' || entry.title.trim() === '') {
        errors.push(`${videoId}: Missing or invalid title field`);
      }

      // CRITICAL: Ensure links field removed
      if (entry.links !== undefined) {
        errors.push(`${videoId}: Links field still present after migration`);
      }

      // Validate no unexpected fields
      const allowedKeys = ['date_added', 'channel', 'title'];
      const entryKeys = Object.keys(entry);
      const unexpectedKeys = entryKeys.filter(key => !allowedKeys.includes(key));
      if (unexpectedKeys.length > 0) {
        errors.push(`${videoId}: Unexpected fields - ${unexpectedKeys.join(', ')}`);
      }
    }

    return errors;
  }

  /**
   * Create backup of registry before migration
   */
  async backupRegistry() {
    const registryPath = this.paths.getRegistryPath();
    const timestamp = dateUtils.generateDateAdded();
    const backupPath = `${registryPath}.backup.${timestamp}`;

    try {
      await fs.copy(registryPath, backupPath);
      console.log(`Registry backup created: ${backupPath}`);
      return backupPath;
    } catch (error) {
      console.error(`Backup failed: ${error.message}`);
      throw new Error('Cannot proceed without backup');
    }
  }
}

module.exports = MigrationService;

// src/services/StorageService.js (MODIFY loadRegistry)

/**
 * Load registry with automatic migration
 * MODIFIED to detect and migrate old format
 * CRITICAL ENHANCEMENT: Added validation phase and rollback on failure
 */
async loadRegistry() {
  await this.initialize();

  const registryPath = this.paths.getRegistryPath();
  const fileExists = await fs.pathExists(registryPath);

  if (!fileExists) {
    return {};
  }

  const registryData = await this.readRegistryFile(registryPath);

  // CRITICAL: Check if migration needed before validation
  const MigrationService = require('./MigrationService');
  const migrationService = new MigrationService(this, this.paths);

  if (migrationService.needsMigration(registryData)) {
    console.log('Old registry format detected - migration required');

    let backupPath;
    try {
      // PHASE 1: Create backup first (CRITICAL)
      backupPath = await migrationService.backupRegistry();

      // PHASE 2: Migrate registry entries
      const migratedData = await migrationService.migrateRegistry(registryData);

      // PHASE 3: CRITICAL VALIDATION before save
      console.log('Validating migrated registry...');
      const validationErrors = migrationService.validateMigratedRegistry(migratedData);
      if (validationErrors.length > 0) {
        console.error('Migration validation failed:');
        validationErrors.forEach(err => console.error(`  - ${err}`));
        throw new Error(`Migration produced ${validationErrors.length} invalid entries`);
      }

      // PHASE 4: Save migrated registry atomically
      await this.saveRegistry(migratedData);

      console.log('Migration complete - registry updated');
      console.log(`Backup preserved at: ${backupPath}`);

      return migratedData;

    } catch (migrationError) {
      console.error('Migration failed:', migrationError.message);

      // CRITICAL: Automatic rollback on failure
      if (backupPath && await fs.pathExists(backupPath)) {
        console.warn('Rolling back to backup...');
        try {
          await fs.copy(backupPath, registryPath, { overwrite: true });
          console.log('Rollback successful - original registry restored');
        } catch (rollbackError) {
          console.error('CRITICAL: Rollback failed:', rollbackError.message);
          console.error(`Manual restore required from: ${backupPath}`);
        }
      }

      throw new Error(`Migration failed and rolled back: ${migrationError.message}`);
    }
  }

  // Validate structure (already new format)
  if (!this.isValidRegistryStructure(registryData)) {
    throw new Error('Registry validation: Structure does not match expected schema');
  }

  return registryData;
}
```

**Critical Points:**

- Migration runs automatically on first loadRegistry call
- **CRITICAL**: Backup created before any changes (safety net)
- **CRITICAL**: Validation phase added after migration, before save
- **CRITICAL**: Automatic rollback on validation failure
- **ENHANCEMENT**: Migration proceeds in 4 phases (backup, migrate, validate, save)
- Date conversion assumes midnight (T0000) for historical data
- Links field deleted from all entries
- Files renamed in batch (transcript_ prefix added)
- **SECURITY**: File locking prevents concurrent migration attempts
- **SECURITY**: Path traversal validation on all file renames
- **BUG FIX**: Rename operations logged for rollback capability
- Atomic operations prevent partial migration
- Migration idempotent (safe to run multiple times)
- Errors logged but don't block entire migration
- **ENHANCEMENT**: Backup path preserved and displayed for manual recovery

#### D. Success Criteria

- [ ] needsMigration detects old format entries
- [ ] backupRegistry creates timestamped backup
- [ ] migrateEntry converts dates to YYMMDDTHHMM
- [ ] migrateEntry removes links field
- [ ] renameTranscriptFiles adds transcript_ prefix
- [ ] **CRITICAL**: File locking prevents concurrent migration
- [ ] **CRITICAL**: validateMigratedRegistry catches all format violations
- [ ] **CRITICAL**: Automatic rollback works on validation failure
- [ ] **CRITICAL**: Automatic rollback works on file rename failure
- [ ] Migration summary logged with statistics
- [ ] Migrated registry passes validation
- [ ] Original data preserved in backup file
- [ ] **ENHANCEMENT**: Rename operations logged for audit trail
- [ ] **ENHANCEMENT**: Backup path displayed for manual recovery

#### E. Dependencies & Inputs

- Requires: All previous steps completed
- Produces: Migrated registry and renamed files
- Impacts: StorageService.loadRegistry, entire data layer

---

### Step 8: Testing and Validation

#### A. Rationale & Objective

Comprehensive testing ensures migration correctness, validates new data format operations, and verifies backward compatibility during transition. Critical validation before production deployment to prevent data loss or corruption.

#### B. Core Concepts & Strategy

Test each component in isolation then integration testing across full workflow. Validate both fresh installations (new format only) and migrations (old to new). Verify edge cases, error handling, and data integrity throughout.

#### C. Implementation Guidelines

**Test Scenarios:**

```javascript
// Test Suite Structure

// 1. Date Utilities Tests
describe('dateUtils', () => {
  test('generateDateAdded returns YYMMDDTHHMM format', () => {
    const timestamp = generateDateAdded();
    expect(timestamp).toMatch(/^\d{6}T\d{4}$/);
  });

  test('isValidTimestamp accepts valid timestamps', () => {
    expect(isValidTimestamp('251122T1430')).toBe(true);
    expect(isValidTimestamp('251122T0000')).toBe(true);
  });

  test('isValidTimestamp rejects invalid formats', () => {
    expect(isValidTimestamp('2025-11-22')).toBe(false);
    expect(isValidTimestamp('251122T2500')).toBe(false); // Invalid hour
    expect(isValidTimestamp('251132T1430')).toBe(false); // Invalid day
  });

  test('convertDateToPrefix converts correctly', () => {
    expect(convertDateToPrefix('2025-11-22')).toBe('251122');
    expect(convertDateToPrefix('2024-01-01')).toBe('240101');
  });

  test('extractDatePrefix returns first 6 chars', () => {
    expect(extractDatePrefix('251122T1430')).toBe('251122');
  });

  test('migrateDate converts with midnight', () => {
    expect(migrateDate('2025-11-22')).toBe('251122T0000');
  });
});

// 2. Channel Formatting Tests
describe('MetadataService', () => {
  test('formatChannel applies same rules as formatTitle', () => {
    const service = new MetadataService();
    expect(service.formatChannel('TechLinked Channel')).toBe('techlinked_channel');
    expect(service.formatChannel('C++ Weekly')).toBe('c_weekly');
  });

  test('fetchVideoMetadata returns formatted channel and title', async () => {
    const service = new MetadataService();
    const metadata = await service.fetchVideoMetadata('dQw4w9WgXcQ');
    expect(metadata.channel).toMatch(/^[a-z0-9][a-z0-9_-]*$/);
    expect(metadata.title).toMatch(/^[a-z0-9][a-z0-9_-]*$/);
  });
});

// 3. Filename Pattern Tests
describe('StorageService filename', () => {
  test('buildFilename includes transcript_ prefix', async () => {
    const filename = await storage.buildFilename('dQw4w9WgXcQ', {
      channel: 'test_channel',
      title: 'test_title'
    });
    expect(filename).toBe('transcript_dQw4w9WgXcQ_test_title.md');
  });

  test('getTranscriptPath finds new pattern first', async () => {
    // Create both old and new files
    await fs.writeFile(oldPath, 'old content');
    await fs.writeFile(newPath, 'new content');

    const found = await storage.getTranscriptPath('dQw4w9WgXcQ');
    expect(found).toBe(newPath); // Prioritizes new pattern
  });
});

// 4. Registry Schema Tests
describe('Registry validation', () => {
  test('rejects entries with links field', () => {
    const invalidEntry = {
      date_added: '251122T1430',
      channel: 'test',
      title: 'test',
      links: [] // NOT ALLOWED
    };
    expect(storage.isValidEntryStructure(invalidEntry)).toBe(false);
  });

  test('accepts entries with new format', () => {
    const validEntry = {
      date_added: '251122T1430',
      channel: 'test_channel',
      title: 'test_title'
    };
    expect(storage.isValidEntryStructure(validEntry)).toBe(true);
  });

  test('rejects old date format in strict mode', () => {
    const oldEntry = {
      date_added: '2025-11-22', // OLD FORMAT
      channel: 'test',
      title: 'test'
    };
    // Should reject after migration complete
  });
});

// 5. Transcript File Structure Tests
describe('Transcript file format', () => {
  test('buildMetadataHeader generates correct structure', () => {
    const header = storage.buildMetadataHeader({
      channel: 'test_channel',
      title: 'test_title'
    }, 'dQw4w9WgXcQ');

    expect(header).toContain('# Transcript');
    expect(header).toContain('## Information');
    expect(header).toContain('Channel: test_channel');
    expect(header).toContain('## Content');
  });

  test('saved transcript has correct structure', async () => {
    await storage.saveTranscript('dQw4w9WgXcQ', 'transcript text', {
      channel: 'test_channel',
      title: 'test_title'
    });

    const content = await fs.readFile(transcriptPath, 'utf8');
    const lines = content.split('\n');

    expect(lines[0]).toBe('# Transcript');
    expect(lines[2]).toBe('## Information');
    expect(lines).toContain('## Content');
  });
});

// 6. Cleanup Date Matching Tests
describe('Clean command', () => {
  test('matches date prefix correctly', () => {
    const input = '2025-11-22';
    const prefix = convertDateToPrefix(input); // '251122'

    expect(extractDatePrefix('251121T2359') < prefix).toBe(true); // DELETE
    expect(extractDatePrefix('251122T0000') >= prefix).toBe(true); // KEEP
    expect(extractDatePrefix('251122T2359') >= prefix).toBe(true); // KEEP
    expect(extractDatePrefix('251123T0000') >= prefix).toBe(true); // KEEP
  });

  test('ignores time portion in comparison', async () => {
    // Create entries with same date, different times
    const registry = {
      'video1': { date_added: '251122T0000', channel: 'c', title: 't' },
      'video2': { date_added: '251122T1200', channel: 'c', title: 't' },
      'video3': { date_added: '251122T2359', channel: 'c', title: 't' }
    };

    // Clean with boundary 2025-11-22
    // All should be kept (boundary excluded)
  });
});

// 7. Migration Tests
describe('Migration', () => {
  test('detects old format entries', () => {
    const oldRegistry = {
      'video1': {
        date_added: '2025-11-22',
        links: ['/path/to/link']
      }
    };

    expect(migration.needsMigration(oldRegistry)).toBe(true);
  });

  test('converts dates correctly', async () => {
    const entry = {
      date_added: '2025-11-22',
      links: []
    };

    const migrated = await migration.migrateEntry('video1', entry, {});
    expect(migrated.date_added).toBe('251122T0000');
    expect(migrated.links).toBeUndefined();
  });

  test('renames files with prefix', async () => {
    // Create old format file
    await fs.writeFile(
      path.join(transcriptsPath, 'dQw4w9WgXcQ_test.md'),
      'content'
    );

    await migration.renameTranscriptFiles(registry, stats);

    const newExists = await fs.pathExists(
      path.join(transcriptsPath, 'transcript_dQw4w9WgXcQ_test.md')
    );
    expect(newExists).toBe(true);
  });

  test('creates backup before migration', async () => {
    const backupPath = await migration.backupRegistry();
    expect(await fs.pathExists(backupPath)).toBe(true);
  });

  // CRITICAL NEW TESTS

  test('validateMigratedRegistry detects invalid timestamps', () => {
    const invalidRegistry = {
      'video1': { date_added: '2025-11-22', channel: 'c', title: 't' } // Old format
    };
    const errors = migration.validateMigratedRegistry(invalidRegistry);
    expect(errors.length).toBeGreaterThan(0);
    expect(errors[0]).toContain('Invalid timestamp format');
  });

  test('validateMigratedRegistry detects remaining links field', () => {
    const invalidRegistry = {
      'video1': { date_added: '251122T1430', channel: 'c', title: 't', links: [] }
    };
    const errors = migration.validateMigratedRegistry(invalidRegistry);
    expect(errors.some(e => e.includes('Links field still present'))).toBe(true);
  });

  test('migration rolls back on validation failure', async () => {
    // Create registry that will fail validation
    const badRegistry = {
      'video1': { date_added: 'invalid', channel: 'c', title: 't' }
    };
    await fs.writeJson(registryPath, badRegistry);

    // Migration should fail and rollback
    await expect(storage.loadRegistry()).rejects.toThrow('Migration failed');

    // Original file should be restored from backup
    const restored = await fs.readJson(registryPath);
    expect(restored).toEqual(badRegistry);
  });

  test('file rename prevents concurrent access with lock', async () => {
    // Create lock file
    const lockPath = path.join(transcriptsPath, '.migration.lock');
    await fs.writeFile(lockPath, '{}', 'utf8');

    // Attempt migration should fail
    await expect(migration.renameTranscriptFiles(registry, {}))
      .rejects.toThrow('Migration already in progress');

    // Cleanup
    await fs.remove(lockPath);
  });

  test('file rename rolls back on error', async () => {
    const oldFile = path.join(transcriptsPath, 'dQw4w9WgXcQ_test.md');
    await fs.writeFile(oldFile, 'content', 'utf8');

    // Force error by making target path read-only
    const newFile = path.join(transcriptsPath, 'transcript_dQw4w9WgXcQ_test.md');
    await fs.writeFile(newFile, 'existing', 'utf8');
    await fs.chmod(newFile, 0o444); // Read-only

    const stats = { filesRenamed: 0, errors: [] };

    // Migration should rollback
    try {
      await migration.renameTranscriptFiles(registry, stats);
    } catch (error) {
      // Expected to fail
    }

    // Original file should still exist
    expect(await fs.pathExists(oldFile)).toBe(true);

    // Cleanup
    await fs.chmod(newFile, 0o644);
    await fs.remove(newFile);
  });

  test('validateMigratedRegistry passes for valid migrated data', () => {
    const validRegistry = {
      'dQw4w9WgXcQ': {
        date_added: '251122T1430',
        channel: 'rick_astley',
        title: 'never_gonna_give_you_up'
      }
    };
    const errors = migration.validateMigratedRegistry(validRegistry);
    expect(errors).toEqual([]);
  });
});

// 8. Integration Tests
describe('Full workflow', () => {
  test('fresh install uses new format', async () => {
    // Process new video
    await transcriptService.processVideo('dQw4w9WgXcQ');

    const registry = await storage.loadRegistry();
    const entry = registry['dQw4w9WgXcQ'];

    expect(entry.date_added).toMatch(/^\d{6}T\d{4}$/);
    expect(entry.channel).toBeDefined();
    expect(entry.title).toBeDefined();
    expect(entry.links).toBeUndefined();

    // Check file
    const files = await fs.readdir(transcriptsPath);
    const transcriptFile = files.find(f => f.startsWith('transcript_dQw4w9WgXcQ'));
    expect(transcriptFile).toBeDefined();
  });

  test('migration from old format works', async () => {
    // Create old format registry
    const oldRegistry = {
      'dQw4w9WgXcQ': {
        date_added: '2025-11-22',
        links: ['/old/path']
      }
    };
    await fs.writeJson(registryPath, oldRegistry);

    // Load triggers migration
    const registry = await storage.loadRegistry();

    expect(registry['dQw4w9WgXcQ'].date_added).toBe('251122T0000');
    expect(registry['dQw4w9WgXcQ'].links).toBeUndefined();
  });

  test('mixed old/new format handled gracefully', async () => {
    const mixedRegistry = {
      'old1': { date_added: '2025-11-22', links: [] },
      'new1': { date_added: '251122T1430', channel: 'c', title: 't' }
    };

    await fs.writeJson(registryPath, mixedRegistry);
    const migrated = await storage.loadRegistry();

    expect(migrated['old1'].date_added).toBe('251122T0000');
    expect(migrated['new1'].date_added).toBe('251122T1430');
  });
});
```

**Manual Testing Checklist:**

1. Fresh installation:
   - [ ] Install on clean system
   - [ ] Process video, verify new format used
   - [ ] Check registry has YYMMDDTHHMM dates
   - [ ] Check files have transcript_ prefix
   - [ ] Verify transcript structure has markdown sections

2. Migration from existing installation:
   - [ ] Backup existing data
   - [ ] Run transcriptor (triggers migration)
   - [ ] Verify backup created
   - [ ] Check all dates converted
   - [ ] Verify links fields removed
   - [ ] Confirm files renamed
   - [ ] Test cleanup command still works

3. Edge cases:
   - [ ] Empty registry (fresh install)
   - [ ] Large registry (performance)
   - [ ] Corrupted entries (error handling)
   - [ ] File rename conflicts (collision handling)
   - [ ] Partial migration failure (rollback)

#### D. Success Criteria

- [ ] All unit tests pass
- [ ] Integration tests pass
- [ ] Fresh install creates correct format
- [ ] Migration converts old data correctly
- [ ] Cleanup command works with new format
- [ ] No data loss during migration
- [ ] Backward compatibility maintained during transition

#### E. Dependencies & Inputs

- Requires: All previous steps completed
- Produces: Validated, tested implementation
- Impacts: Entire codebase validation

---

## Technical Considerations

### Architecture Impact

- **StorageService**: Date generation, validation, filename building, header generation
- **MetadataService**: Channel formatting added
- **MigrationService**: New service for data transformation
- **dateUtils**: New utility module for timestamp operations
- **validators.js**: Updated to accept new timestamp format
- **clean.js**: Date matching logic modified

### Integration Points

- Registry load triggers automatic migration
- All file operations use new filename pattern
- Cleanup command uses prefix-based date matching
- Transcript creation uses structured markdown format

### Risk Mitigation

| Risk | Likelihood | Impact | Mitigation Strategy |
|------|------------|--------|-------------------|
| Data loss during migration | Low | **CRITICAL** | **ENHANCED**: Automatic backup + validation phase + automatic rollback on failure |
| Validation rejects valid data | Low | High | **ENHANCED**: Support both formats + comprehensive validation tests + detailed error messages |
| File rename conflicts | Low | Medium | **ENHANCED**: Collision detection + skip existing + audit trail logging |
| Performance degradation | Low | Low | Migration runs once, minimal overhead afterward |
| Partial migration failure | Low | High | **ENHANCED**: Transaction boundaries + file locking + automatic rollback + rename log |
| Concurrent migration attempts | Low | **CRITICAL** | **NEW**: Lock file mechanism prevents simultaneous migrations |
| Timestamp injection/corruption | Low | Medium | **NEW**: Generated timestamps validated before use + Date object validity checks |
| Path traversal during rename | Very Low | **CRITICAL** | **NEW**: Explicit path validation before all file operations |
| Registry corruption post-migration | Very Low | **CRITICAL** | **NEW**: Validation phase after migration, before save |

### Performance Considerations

- Migration runs once per installation (first load)
- Backup creation adds ~100ms for typical registry
- File rename operations batched for efficiency
- Registry cache invalidated during migration (one-time cost)
- No ongoing performance impact after migration

## Testing Strategy

### Unit Testing

- Date utilities (generation, validation, conversion)
- Channel formatting (same as title)
- Filename building (prefix addition)
- Registry validation (new schema)
- Migration logic (entry conversion, file rename)

### Integration Testing

- Full workflow: process video with new format
- Migration workflow: old to new conversion
- Cleanup workflow: date matching with prefixes
- Mixed format handling: old and new entries coexist

### Edge Cases

- Empty registry (no migration needed)
- All old format (full migration)
- Mixed old/new (partial migration)
- Invalid dates (error handling)
- Missing files (orphan cleanup)
- Filename collisions (conflict resolution)

## Implementation Notes

### Code Organization

```
src/
├── services/
│   ├── StorageService.js (MODIFY: date, filename, header, validation)
│   ├── MetadataService.js (MODIFY: add formatChannel)
│   ├── MigrationService.js (NEW: migration logic)
├── utils/
│   ├── dateUtils.js (NEW: timestamp operations)
│   ├── validators.js (MODIFY: accept new timestamp format)
├── commands/
│   ├── clean.js (MODIFY: date matching logic)
```

### Coding Standards

- Use dateUtils for all timestamp operations
- Never hardcode date format strings
- Always create backup before destructive operations
- Log migration actions for audit trail
- Validate data after every transformation
- Maintain backward compatibility during transition

### Documentation Requirements

- Update README with new data format
- Document migration process
- Add timestamp format specification
- Update API documentation
- Add migration troubleshooting guide

## Estimated Effort

| Component | Original | Post-Review | Complexity |
|-----------|----------|-------------|------------|
| Date utilities (Step 1) | 3 hours | **4 hours** | Medium (added validation) |
| Channel formatting (Step 2) | 1 hour | **2 hours** | Low (added guards) |
| Filename patterns (Step 3) | 2 hours | 2 hours | Medium |
| Registry cleanup (Step 4) | 2 hours | 2 hours | Low |
| File structure (Step 5) | 1 hour | 1 hour | Low |
| Cleanup modifications (Step 6) | 2 hours | 2 hours | Medium |
| Migration implementation (Step 7) | 6 hours | **10 hours** | **High** (added validation, locking, rollback) |
| Testing & validation (Step 8) | 4 hours | **7 hours** | Medium (expanded test coverage) |
| **Total** | **21 hours** | **30 hours** | Overall: **High** |

**Effort increase justification**: Enhanced security, automatic rollback, validation phase, and comprehensive error handling add ~9 hours but significantly reduce risk of data loss and corruption.

## Next Steps (Implementation Order)

### Phase 1: Foundation (Steps 1-2)
1. Create src/utils/dateUtils.js with all timestamp functions
   - generateDateAdded with validation
   - isValidTimestamp with enhanced checks
   - convertDateToPrefix for cleanup
   - extractDatePrefix for comparison
   - migrateDate for data conversion
2. Update validators.js to accept both YYMMDDTHHMM and YYYY-MM-DD
3. Add formatChannel to MetadataService with null guards

### Phase 2: Schema Updates (Steps 3-5)
4. Update StorageService ALLOWED_ENTRY_KEYS (remove links)
5. Modify buildFilename to add transcript_ prefix
6. Update buildMetadataHeader to use formatted channel
7. Update isValidEntryStructure to reject links field

### Phase 3: Migration Implementation (Steps 6-7)
8. Implement MigrationService.js with:
   - needsMigration detection
   - migrateEntry conversion
   - renameTranscriptFiles with locking and rollback
   - validateMigratedRegistry validation phase
   - backupRegistry with error handling
9. Modify StorageService.loadRegistry to trigger migration with 4-phase approach
10. Update clean.js date matching logic for prefix comparison

### Phase 4: Testing & Validation (Step 8)
11. Unit tests for dateUtils functions
12. Unit tests for validation functions
13. Unit tests for migration service methods
14. Integration tests for full migration workflow
15. Edge case tests for rollback scenarios
16. Performance tests for large registries

## References

- Functional Requirements: FR-2.4, FR-2.5, FR-3.2, FR-6.1, FR-11
- Technical Requirements: TR-23, TR-24, TR-27, TR-30, TR-31, TR-32, TR-33
- Business Rules: BR-3 (date handling)
- Related Tasks: 10.0 (Metadata Collection Feature - completed)
- External Documentation: None

## Migration Safety Notes

**CRITICAL - Read Before Implementation:**

1. **Backup is mandatory**: Migration will not proceed without successful backup
2. **Atomic operations**: Each registry write is atomic (temp file + rename)
3. **Idempotent migration**: Safe to run multiple times (checks format first)
4. **Error isolation**: Migration errors for individual entries don't block others
5. **Rollback strategy**: Original backup available at data.json.backup.YYMMDDTHHMM
6. **Validation gates**: Migrated data must pass validation before save
7. **Audit trail**: All migration actions logged to console
8. **No data deletion**: Old format preserved in backup, new format written separately

### POST-REVIEW ENHANCEMENTS

9. **CRITICAL: Automatic rollback**: Migration failures trigger automatic registry restoration
10. **CRITICAL: File locking**: Lock file prevents concurrent migration attempts
11. **CRITICAL: Validation phase**: Post-migration validation before save prevents corruption
12. **SECURITY: Path validation**: All file operations validate paths to prevent traversal
13. **SECURITY: Timestamp validation**: Generated timestamps validated before use
14. **BUG PREVENTION: Rename rollback**: File rename operations logged and rolled back on error
15. **ENHANCEMENT: Detailed errors**: Validation provides specific, actionable error messages

### Migration Phases (4-Phase Approach)

**PHASE 1: BACKUP** - Create timestamped backup (CRITICAL: failure aborts migration)
**PHASE 2: MIGRATE** - Transform registry entries and rename files
**PHASE 3: VALIDATE** - Validate all migrated data (NEW: catches corruption before save)
**PHASE 4: SAVE** - Atomically write new registry (only if validation passes)

**Failure at any phase triggers automatic rollback to backup.**

### Manual Rollback Procedure

Only needed if automatic rollback fails:

```bash
# 1. Stop transcriptor
# 2. Restore backup
cp ~/.transcriptor/data.json.backup.YYMMDDTHHMM ~/.transcriptor/data.json
# 3. Rename files back (if needed)
cd ~/.transcriptor/transcripts
for f in transcript_*.md; do mv "$f" "${f#transcript_}"; done
# 4. Remove lock file if exists
rm -f ~/.transcriptor/transcripts/.migration.lock
# 5. Restart transcriptor
```

### Lock File Cleanup

If migration is interrupted (process killed), manually remove lock file:

```bash
rm -f ~/.transcriptor/transcripts/.migration.lock
```

---

## COMPREHENSIVE REVIEW SUMMARY

### Implementation Readiness Score: 9/10

**Requirements Coverage**: 2/2 - All FR/TR requirements fully addressed with enhancements
**Bug Prevention**: 2/2 - Critical bugs identified and fixed (race conditions, validation gaps, rollback)
**Testability**: 2/2 - Comprehensive test scenarios including rollback and edge cases
**Clean Code**: 2/2 - Transaction boundaries, separation of concerns, detailed error messages
**Security**: 1/2 - Security enhancements added but -1 for complexity introduced by migration logic

### Critical Issues Identified and Resolved

1. **CRITICAL: Registry Links Field Conflict** ✓ FIXED
   - Issue: Plan removes links from schema but StorageService.js still includes it
   - Fix: Migration validation ensures links field removed before save

2. **CRITICAL: Date Format Validation Gap** ✓ FIXED
   - Issue: validators.js only accepts YYYY-MM-DD, would reject new format
   - Fix: Updated isValidDate to support both formats during migration

3. **CRITICAL: Filename Migration Race Condition** ✓ FIXED
   - Issue: No safeguards for concurrent file access during rename
   - Fix: Lock file mechanism + rollback logging + path validation

4. **SECURITY: Timestamp Injection Risk** ✓ FIXED
   - Issue: generateDateAdded uses client time without validation
   - Fix: Generated timestamps validated before return + Date object checks

5. **BUG PREVENTION: Missing Rollback Mechanism** ✓ FIXED
   - Issue: Backup created but no automated rollback on failure
   - Fix: 4-phase migration with automatic rollback at each phase

### Major Enhancements Added

1. **Migration Transaction Boundaries**: 4-phase approach (Backup → Migrate → Validate → Save)
2. **Automatic Rollback**: Registry and file operations rolled back on any failure
3. **Validation Phase**: Post-migration validation prevents corrupted data from being saved
4. **File Locking**: Prevents concurrent migration attempts
5. **Audit Trail**: Comprehensive logging with rename log and detailed error messages
6. **Enhanced Testing**: 15 new test scenarios covering rollback, validation, and edge cases

### Risk Assessment Post-Review

| Risk Category | Before Review | After Review | Change |
|---------------|---------------|--------------|--------|
| Data Loss | Medium | **Low** | ↓↓ Improved |
| Data Corruption | Medium | **Low** | ↓↓ Improved |
| Concurrent Access | High | **Very Low** | ↓↓↓ Significant |
| Partial Failure | High | **Low** | ↓↓ Improved |
| Security Vulnerabilities | Medium | **Low** | ↓ Improved |

### Implementation Confidence: HIGH

**Pros:**
- Comprehensive error handling and rollback mechanisms
- Validation gates at multiple points prevent corruption
- Backward compatibility maintained during migration
- Detailed audit trail for troubleshooting
- Transaction boundaries ensure atomic operations

**Cons:**
- Increased complexity (30 hours vs 21 hours)
- More code to maintain (MigrationService + validation)
- Lock file mechanism requires manual cleanup if interrupted

**Recommendation:** PROCEED WITH IMPLEMENTATION

The enhanced plan significantly reduces data loss and corruption risks through validation phases, automatic rollback, and transaction boundaries. The additional 9 hours of effort is justified by the critical nature of data migration and the project's lack of testing infrastructure.

### Pre-Implementation Checklist

- [ ] Review all 5 critical issues and understand fixes
- [ ] Understand 4-phase migration workflow
- [ ] Review manual rollback procedure
- [ ] Ensure backup strategy is clear
- [ ] Review lock file cleanup process
- [ ] Understand validation error messages
- [ ] Review test scenarios for edge cases
- [ ] Confirm StorageService.ALLOWED_ENTRY_KEYS will be updated
- [ ] Confirm validators.js will support both formats
- [ ] Ready to implement dateUtils.js with all validations

### Post-Implementation Validation

After implementation, verify:

1. All unit tests pass (dateUtils, validators, migration service)
2. Integration tests pass (full migration workflow)
3. Rollback tests pass (validation failure, file rename failure)
4. Fresh install creates new format correctly
5. Migration from old format completes successfully
6. Backup created with correct timestamp
7. Lock file removed after migration
8. Audit logs readable and complete
9. Manual rollback procedure works
10. Performance acceptable for large registries (benchmark >1000 entries)

**END OF COMPREHENSIVE REVIEW**
