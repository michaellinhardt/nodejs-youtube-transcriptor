# Remediation Plan: Bug Fixes & Resilience

**Date:** 2025-11-19
**Task Reference:** [3.3 from ./dev/tasks.md]
**Bugs Addressed:** [BUG-001, BUG-002, BUG-003, BUG-004, BUG-005]
**Status:** Ready for Implementation

## Plan Overview

This plan addresses critical bugs and resilience issues discovered in the newly implemented file operations methods (saveTranscript, readTranscript, transcriptExists, deleteTranscript) within StorageService.js. The implementation contains five distinct bugs: a race condition in transcriptExists, incorrect error propagation in readTranscript, a TOCTOU vulnerability in deleteTranscript, missing race condition handling in saveTranscript, and inadequate error handling for nested initialization failures. These bugs could lead to data corruption, silent failures, and inconsistent system state. The remediation focuses on atomic operations, proper error handling, defensive programming, and eliminating time-of-check to time-of-use vulnerabilities.

## Tasks Planned

[Explicitly list the tasks targeted by this plan with full hierarchy, if applicable]

- 3.3 File operations (implements TR-17)
  - 3.3.1 Implement transcript save functionality
  - 3.3.2 Create transcript read methods
  - 3.3.3 Add file existence checking
  - 3.3.4 Implement file deletion with error handling

## High-Level Steps

1. Fix race condition in transcriptExists (BUG-001)
2. Fix error propagation in readTranscript (BUG-002)
3. Fix TOCTOU vulnerability in deleteTranscript (BUG-003)
4. Add race condition handling to saveTranscript (BUG-004)
5. Fix initialization error propagation (BUG-005)

## Detailed Breakdown

### Step 1: Fix Race Condition in transcriptExists (BUG-001)

#### A. Rationale & Objective

Critical race condition exists between existence check and stat() call in transcriptExists. Between fs.pathExists() returning true and fs.stat() executing, the file can be deleted by another process or concurrent operation. This creates a TOCTOU (Time-Of-Check-Time-Of-Use) vulnerability causing unhandled ENOENT exceptions.

#### B. Root Cause Analysis

Lines 441-456 in StorageService.js:

```javascript
const exists = await fs.pathExists(transcriptPath);

// ENHANCEMENT: If file exists, verify it's readable and non-empty
if (exists) {
  try {
    const stats = await fs.stat(transcriptPath);
    // Return false for zero-byte files (corrupted)
    if (stats.size === 0) {
      return false;
    }
  } catch (statError) {
    // If we can't stat the file (permission issues), consider it non-existent
    return false;
  }
}
```

The gap between `pathExists()` and `stat()` allows file deletion. The catch block incorrectly assumes all stat errors are permission-related, masking actual ENOENT race conditions.

#### C. Recommended Fix Strategy

Eliminate existence check entirely. Use fs.stat() directly and handle ENOENT as "does not exist". This makes the operation atomic and eliminates the race window.

#### D. Implementation Guide

```javascript
// Before (buggy - has race condition)
async transcriptExists(videoId) {
  await this.initialize();

  if (!validators.isValidVideoId(videoId)) {
    throw new Error(`Invalid video ID format: ${videoId}`);
  }

  const transcriptPath = path.join(
    this.paths.getTranscriptsPath(),
    `${videoId}.md`
  );

  try {
    const exists = await fs.pathExists(transcriptPath);

    if (exists) {
      try {
        const stats = await fs.stat(transcriptPath);
        if (stats.size === 0) {
          return false;
        }
      } catch (statError) {
        return false;
      }
    }

    return exists;
  } catch (error) {
    console.warn(`transcriptExists check failed for ${videoId}: ${error.message}`);
    return false;
  }
}

// After (fixed - atomic operation)
async transcriptExists(videoId) {
  await this.initialize();

  if (!validators.isValidVideoId(videoId)) {
    throw new Error(`Invalid video ID format: ${videoId}`);
  }

  const transcriptPath = path.join(
    this.paths.getTranscriptsPath(),
    `${videoId}.md`
  );

  try {
    // Direct stat - atomic operation
    const stats = await fs.stat(transcriptPath);

    // Verify it's a file (not directory/symlink)
    if (!stats.isFile()) {
      return false;
    }

    // Return false for zero-byte files (corrupted)
    if (stats.size === 0) {
      return false;
    }

    return true;
  } catch (error) {
    // File doesn't exist - expected case
    if (error.code === 'ENOENT') {
      return false;
    }

    // Permission errors - treat as non-existent
    if (error.code === 'EACCES' || error.code === 'EPERM') {
      console.warn(`Permission denied checking transcript ${videoId}`);
      return false;
    }

    // Unexpected errors - log and return false defensively
    console.warn(`transcriptExists check failed for ${videoId}: ${error.message}`);
    return false;
  }
}
```

#### E. Test Cases to Add

```javascript
// Test concurrent deletion race
test('transcriptExists handles file deleted between checks', async () => {
  // Create file
  await storageService.saveTranscript('test123', 'content');

  // Stub fs.stat to delete file before returning
  const originalStat = fs.stat;
  fs.stat = async (path) => {
    await fs.remove(path);
    return originalStat(path); // Will throw ENOENT
  };

  const exists = await storageService.transcriptExists('test123');
  expect(exists).toBe(false);

  fs.stat = originalStat;
});

// Test zero-byte file detection
test('transcriptExists returns false for empty files', async () => {
  const path = '~/.transcriptor/transcripts/test123.md';
  await fs.writeFile(path, '', 'utf8');

  const exists = await storageService.transcriptExists('test123');
  expect(exists).toBe(false);
});

// Test directory collision
test('transcriptExists returns false for directories', async () => {
  const path = '~/.transcriptor/transcripts/test123.md';
  await fs.mkdir(path);

  const exists = await storageService.transcriptExists('test123');
  expect(exists).toBe(false);
});
```

---

### Step 2: Fix Error Propagation in readTranscript (BUG-002)

#### A. Rationale & Objective

Lines 408-410 contain redundant and confusing error handling that re-throws custom errors using string matching. This pattern is fragile, inefficient, and masks the actual error type, making debugging difficult.

#### B. Root Cause Analysis

```javascript
// Re-throw with context (includes custom errors like empty file)
if (error.message.includes('Transcript file is empty')) {
  throw error;
}

throw new Error(`Failed to read transcript ${videoId}: ${error.message}`);
```

The code checks if the error message contains a specific string to determine if it should re-throw the original error. This is problematic:

1. String matching is fragile (message changes break logic)
2. Unnecessary performance overhead
3. Loses error type information
4. Makes debugging harder
5. Violates DRY principle

#### C. Recommended Fix Strategy

Remove the redundant check. Custom errors thrown within the try block are already Error instances with proper messages. Simply wrap ALL errors that aren't ENOENT or permission errors.

#### D. Implementation Guide

```javascript
// Before (buggy - redundant error check)
async readTranscript(videoId) {
  await this.initialize();

  if (!validators.isValidVideoId(videoId)) {
    throw new Error(`Invalid video ID format: ${videoId}`);
  }

  const transcriptPath = path.join(
    this.paths.getTranscriptsPath(),
    `${videoId}.md`
  );

  try {
    const content = await fs.readFile(transcriptPath, { encoding: 'utf8' });

    if (content.length === 0) {
      throw new Error(`Transcript file is empty for video ID: ${videoId}`);
    }

    return content;
  } catch (error) {
    if (error.code === 'ENOENT') {
      throw new Error(`Transcript not found: ${videoId}`);
    }

    if (error.code === 'EACCES' || error.code === 'EPERM') {
      throw new Error(`Permission denied reading transcript ${videoId}: ${error.message}`);
    }

    // BUGGY: Redundant check
    if (error.message.includes('Transcript file is empty')) {
      throw error;
    }

    throw new Error(`Failed to read transcript ${videoId}: ${error.message}`);
  }
}

// After (fixed - clean error handling)
async readTranscript(videoId) {
  await this.initialize();

  if (!validators.isValidVideoId(videoId)) {
    throw new Error(`Invalid video ID format: ${videoId}`);
  }

  const transcriptPath = path.join(
    this.paths.getTranscriptsPath(),
    `${videoId}.md`
  );

  try {
    const content = await fs.readFile(transcriptPath, { encoding: 'utf8' });

    if (content.length === 0) {
      throw new Error(`Transcript file is empty for video ID: ${videoId}`);
    }

    return content;
  } catch (error) {
    // File not found - expected error case
    if (error.code === 'ENOENT') {
      throw new Error(`Transcript not found: ${videoId}`);
    }

    // Permission denied - expected error case
    if (error.code === 'EACCES' || error.code === 'EPERM') {
      throw new Error(`Permission denied reading transcript ${videoId}: ${error.message}`);
    }

    // All other errors (including custom "empty file" error from above)
    // Already have proper context, just re-throw
    throw error;
  }
}
```

#### E. Test Cases to Add

```javascript
// Test empty file error propagation
test('readTranscript throws correct error for empty file', async () => {
  await fs.writeFile('~/.transcriptor/transcripts/test123.md', '', 'utf8');

  await expect(storageService.readTranscript('test123')).rejects.toThrow(
    'Transcript file is empty for video ID: test123'
  );
});

// Test filesystem error wrapping
test('readTranscript preserves original error for unexpected failures', async () => {
  // Mock fs.readFile to throw unexpected error
  const originalReadFile = fs.readFile;
  fs.readFile = async () => {
    throw new Error('Disk I/O error');
  };

  await expect(storageService.readTranscript('test123')).rejects.toThrow('Disk I/O error');

  fs.readFile = originalReadFile;
});
```

---

### Step 3: Fix TOCTOU Vulnerability in deleteTranscript (BUG-003)

#### A. Rationale & Objective

Lines 491-503 implement a classic Time-Of-Check-Time-Of-Use (TOCTOU) vulnerability. The code checks file existence, then verifies it's a file, then deletes. Multiple race windows exist between these operations where the file can be deleted, replaced with a directory, or replaced with a symlink by another process.

#### B. Root Cause Analysis

```javascript
// ENHANCEMENT: Check file existence before deletion for better logging
const exists = await fs.pathExists(transcriptPath);

if (!exists) {
  return;
}

// ENHANCEMENT: Verify file is actually a file (not directory)
const stats = await fs.stat(transcriptPath);
if (!stats.isFile()) {
  throw new Error(`Path exists but is not a file (safety check): ${videoId}`);
}

// Remove file (idempotent, handles ENOENT gracefully)
await fs.remove(transcriptPath);
```

Three separate async operations create two race windows:

1. Between pathExists() and stat(): File can be deleted
2. Between stat() and remove(): File can be replaced with directory

The "safety check" comment suggests this prevents deleting directories, but the race condition means it's ineffective.

#### C. Recommended Fix Strategy

Use fs.unlink() instead of fs.remove(). unlink() only removes files (fails on directories), eliminating the need for existence/type checking. Handle ENOENT for idempotency. This makes the operation atomic.

#### D. Implementation Guide

```javascript
// Before (buggy - TOCTOU vulnerability)
async deleteTranscript(videoId) {
  await this.initialize();

  if (!validators.isValidVideoId(videoId)) {
    throw new Error(`Invalid video ID format: ${videoId}`);
  }

  const transcriptPath = path.join(
    this.paths.getTranscriptsPath(),
    `${videoId}.md`
  );

  try {
    // BUGGY: Race window #1
    const exists = await fs.pathExists(transcriptPath);

    if (!exists) {
      return;
    }

    // BUGGY: Race window #2
    const stats = await fs.stat(transcriptPath);
    if (!stats.isFile()) {
      throw new Error(`Path exists but is not a file (safety check): ${videoId}`);
    }

    // BUGGY: File state may have changed
    await fs.remove(transcriptPath);
  } catch (error) {
    if (error.code === 'ENOENT') {
      return;
    }

    if (error.code === 'EACCES' || error.code === 'EPERM') {
      throw new Error(`Permission denied deleting transcript ${videoId}: ${error.message}`);
    }

    if (error.message.includes('not a file')) {
      throw error;
    }

    throw new Error(`Failed to delete transcript ${videoId}: ${error.message}`);
  }
}

// After (fixed - atomic operation)
async deleteTranscript(videoId) {
  await this.initialize();

  if (!validators.isValidVideoId(videoId)) {
    throw new Error(`Invalid video ID format: ${videoId}`);
  }

  const transcriptPath = path.join(
    this.paths.getTranscriptsPath(),
    `${videoId}.md`
  );

  try {
    // Use unlink instead of remove - only works on files (atomic)
    // Fails on directories with EISDIR/EPERM
    await fs.unlink(transcriptPath);
  } catch (error) {
    // File doesn't exist - idempotent success
    if (error.code === 'ENOENT') {
      return;
    }

    // Path is a directory - safety check passed atomically
    if (error.code === 'EISDIR' || error.code === 'EPERM') {
      throw new Error(`Cannot delete: path is not a file (${videoId})`);
    }

    // Permission denied
    if (error.code === 'EACCES') {
      throw new Error(`Permission denied deleting transcript ${videoId}: ${error.message}`);
    }

    // Other errors with context
    throw new Error(`Failed to delete transcript ${videoId}: ${error.message}`);
  }
}
```

#### E. Test Cases to Add

```javascript
// Test idempotent deletion
test('deleteTranscript succeeds when file already deleted', async () => {
  await expect(storageService.deleteTranscript('nonexistent')).resolves.toBeUndefined();
});

// Test directory protection
test('deleteTranscript refuses to delete directories', async () => {
  await fs.mkdir('~/.transcriptor/transcripts/test123.md');

  await expect(storageService.deleteTranscript('test123')).rejects.toThrow(
    'Cannot delete: path is not a file'
  );
});

// Test concurrent deletion race
test('deleteTranscript handles concurrent deletion', async () => {
  await storageService.saveTranscript('test123', 'content');

  // Start two deletions simultaneously
  const [result1, result2] = await Promise.all([
    storageService.deleteTranscript('test123'),
    storageService.deleteTranscript('test123'),
  ]);

  // Both should succeed (idempotent)
  expect(result1).toBeUndefined();
  expect(result2).toBeUndefined();
});

// Test directory replacement race
test('deleteTranscript handles file->directory replacement race', async () => {
  await storageService.saveTranscript('test123', 'content');

  // Mock unlink to replace file with directory mid-operation
  const originalUnlink = fs.unlink;
  let callCount = 0;
  fs.unlink = async (path) => {
    if (callCount++ === 0) {
      await fs.remove(path);
      await fs.mkdir(path);
      throw Object.assign(new Error('EISDIR'), { code: 'EISDIR' });
    }
    return originalUnlink(path);
  };

  await expect(storageService.deleteTranscript('test123')).rejects.toThrow(
    'Cannot delete: path is not a file'
  );

  fs.unlink = originalUnlink;
});
```

---

### Step 4: Add Race Condition Handling to saveTranscript (BUG-004)

#### A. Rationale & Objective

Lines 354-359 in saveTranscript lack proper handling for directory creation race conditions. Multiple processes can call saveTranscript concurrently for different videos, causing fs.ensureDir to fail with EEXIST when two processes try to create the same directory simultaneously.

#### B. Root Cause Analysis

```javascript
// Ensure directory exists (idempotent)
await fs.ensureDir(path.dirname(transcriptPath));

try {
  // Write with UTF-8 encoding
  await fs.writeFile(transcriptPath, content, { encoding: 'utf8' });
} catch (error) {
  // Enhanced error context
  throw new Error(`Failed to save transcript ${videoId}: ${error.message}`);
}
```

While fs.ensureDir claims to be idempotent, concurrent calls can still cause issues. If ensureDir throws EEXIST, the catch block wraps it incorrectly. Additionally, fs.writeFile failures aren't distinguished from directory creation failures.

#### C. Recommended Fix Strategy

Wrap fs.ensureDir in its own try-catch to handle EEXIST specifically. Separate directory creation errors from write errors for better diagnostics.

#### D. Implementation Guide

```javascript
// Before (buggy - inadequate race handling)
async saveTranscript(videoId, content) {
  await this.initialize();

  if (!validators.isValidVideoId(videoId)) {
    throw new Error(`Invalid video ID format: ${videoId}`);
  }

  if (typeof content !== 'string') {
    throw new Error(`Invalid content type: expected string, got ${typeof content}`);
  }

  if (content.length === 0) {
    throw new Error(`Cannot save empty transcript for video ID: ${videoId}`);
  }

  const maxSizeBytes = 10 * 1024 * 1024;
  const contentSizeBytes = Buffer.byteLength(content, 'utf8');
  if (contentSizeBytes > maxSizeBytes) {
    throw new Error(`Transcript exceeds size limit (${contentSizeBytes} bytes > ${maxSizeBytes} bytes) for video ID: ${videoId}`);
  }

  const transcriptPath = path.join(
    this.paths.getTranscriptsPath(),
    `${videoId}.md`
  );

  // BUGGY: No error handling for ensureDir
  await fs.ensureDir(path.dirname(transcriptPath));

  try {
    await fs.writeFile(transcriptPath, content, { encoding: 'utf8' });
  } catch (error) {
    throw new Error(`Failed to save transcript ${videoId}: ${error.message}`);
  }
}

// After (fixed - explicit race handling)
async saveTranscript(videoId, content) {
  await this.initialize();

  if (!validators.isValidVideoId(videoId)) {
    throw new Error(`Invalid video ID format: ${videoId}`);
  }

  if (typeof content !== 'string') {
    throw new Error(`Invalid content type: expected string, got ${typeof content}`);
  }

  if (content.length === 0) {
    throw new Error(`Cannot save empty transcript for video ID: ${videoId}`);
  }

  const maxSizeBytes = 10 * 1024 * 1024;
  const contentSizeBytes = Buffer.byteLength(content, 'utf8');
  if (contentSizeBytes > maxSizeBytes) {
    throw new Error(`Transcript exceeds size limit (${contentSizeBytes} bytes > ${maxSizeBytes} bytes) for video ID: ${videoId}`);
  }

  const transcriptPath = path.join(
    this.paths.getTranscriptsPath(),
    `${videoId}.md`
  );

  // Ensure directory exists with explicit race handling
  try {
    await fs.ensureDir(path.dirname(transcriptPath));
  } catch (dirError) {
    // EEXIST is safe to ignore (another process created it)
    if (dirError.code !== 'EEXIST') {
      throw new Error(`Failed to create transcript directory: ${dirError.message}`);
    }
    // If EEXIST, directory exists - continue to write
  }

  // Write file
  try {
    await fs.writeFile(transcriptPath, content, { encoding: 'utf8' });
  } catch (writeError) {
    throw new Error(`Failed to write transcript ${videoId}: ${writeError.message}`);
  }
}
```

#### E. Test Cases to Add

```javascript
// Test concurrent directory creation
test('saveTranscript handles concurrent directory creation', async () => {
  // Ensure directory doesn't exist
  await fs.remove('~/.transcriptor/transcripts');

  // Save multiple transcripts concurrently
  const promises = [];
  for (let i = 0; i < 10; i++) {
    promises.push(storageService.saveTranscript(`test${i}abcde`, `content ${i}`));
  }

  // All should succeed without EEXIST errors
  await expect(Promise.all(promises)).resolves.toBeDefined();
});

// Test write failure after directory creation
test('saveTranscript distinguishes directory vs write errors', async () => {
  // Mock writeFile to fail
  const originalWrite = fs.writeFile;
  fs.writeFile = async () => {
    throw new Error('Disk full');
  };

  await expect(storageService.saveTranscript('test123', 'content')).rejects.toThrow(
    'Failed to write transcript test123: Disk full'
  );

  fs.writeFile = originalWrite;
});
```

---

### Step 5: Fix Initialization Error Propagation (BUG-005)

#### A. Rationale & Objective

All file operation methods call `await this.initialize()` at the start, but don't handle initialization failures properly. If initialize() throws (e.g., due to permission errors creating ~/.transcriptor), the error propagates unmodified, lacking context about which operation was attempting initialization.

#### B. Root Cause Analysis

```javascript
async saveTranscript(videoId, content) {
  // BUGGY: Initialization errors lack operation context
  await this.initialize();

  // ... validation and processing
}
```

If `initialize()` throws due to filesystem errors, the user sees "Storage initialization failed: EACCES" without knowing whether they were trying to save, read, or delete a transcript. This makes debugging difficult.

Additionally, each method calls initialize() independently, but there's no guarantee about the state if initialization fails - the `initialized` flag might be inconsistent.

#### C. Recommended Fix Strategy

Wrap initialize() calls in try-catch blocks that add operation-specific context to errors. Ensure consistent error messages across all methods.

#### D. Implementation Guide

```javascript
// Before (all methods have this pattern)
async saveTranscript(videoId, content) {
  await this.initialize();  // BUGGY: Errors lack context

  if (!validators.isValidVideoId(videoId)) {
    throw new Error(`Invalid video ID format: ${videoId}`);
  }
  // ... rest of method
}

// After (add context to initialization errors)
async saveTranscript(videoId, content) {
  try {
    await this.initialize();
  } catch (initError) {
    throw new Error(`Cannot save transcript (initialization failed): ${initError.message}`);
  }

  if (!validators.isValidVideoId(videoId)) {
    throw new Error(`Invalid video ID format: ${videoId}`);
  }
  // ... rest of method
}

async readTranscript(videoId) {
  try {
    await this.initialize();
  } catch (initError) {
    throw new Error(`Cannot read transcript (initialization failed): ${initError.message}`);
  }

  if (!validators.isValidVideoId(videoId)) {
    throw new Error(`Invalid video ID format: ${videoId}`);
  }
  // ... rest of method
}

async transcriptExists(videoId) {
  try {
    await this.initialize();
  } catch (initError) {
    throw new Error(`Cannot check transcript existence (initialization failed): ${initError.message}`);
  }

  if (!validators.isValidVideoId(videoId)) {
    throw new Error(`Invalid video ID format: ${videoId}`);
  }
  // ... rest of method
}

async deleteTranscript(videoId) {
  try {
    await this.initialize();
  } catch (initError) {
    throw new Error(`Cannot delete transcript (initialization failed): ${initError.message}`);
  }

  if (!validators.isValidVideoId(videoId)) {
    throw new Error(`Invalid video ID format: ${videoId}`);
  }
  // ... rest of method
}
```

#### E. Test Cases to Add

```javascript
// Test initialization failure context
test('saveTranscript provides context for initialization failures', async () => {
  // Mock initialize to fail
  const originalInit = storageService.initialize;
  storageService.initialize = async () => {
    throw new Error('Permission denied');
  };

  await expect(storageService.saveTranscript('test123', 'content')).rejects.toThrow(
    'Cannot save transcript (initialization failed): Permission denied'
  );

  storageService.initialize = originalInit;
});

test('readTranscript provides context for initialization failures', async () => {
  const originalInit = storageService.initialize;
  storageService.initialize = async () => {
    throw new Error('EACCES');
  };

  await expect(storageService.readTranscript('test123')).rejects.toThrow(
    'Cannot read transcript (initialization failed): EACCES'
  );

  storageService.initialize = originalInit;
});

test('deleteTranscript provides context for initialization failures', async () => {
  const originalInit = storageService.initialize;
  storageService.initialize = async () => {
    throw new Error('Disk full');
  };

  await expect(storageService.deleteTranscript('test123')).rejects.toThrow(
    'Cannot delete transcript (initialization failed): Disk full'
  );

  storageService.initialize = originalInit;
});
```

---

## Validation Checklist

- [ ] BUG-001: Race condition in transcriptExists eliminated using atomic fs.stat()
- [ ] BUG-002: Redundant error propagation removed from readTranscript
- [ ] BUG-003: TOCTOU vulnerability fixed in deleteTranscript using fs.unlink()
- [ ] BUG-004: Race condition handling added to saveTranscript directory creation
- [ ] BUG-005: Initialization error context added to all file operation methods
- [ ] All edge cases handled (ENOENT, EACCES, EPERM, EISDIR, EEXIST)
- [ ] No new bugs introduced
- [ ] Error messages provide clear context
- [ ] Operations are atomic where possible
- [ ] Idempotent operations remain idempotent

## Additional Observations

### Non-Critical Issues (Not Bugs, But Worth Noting)

1. **Empty Content Check Position** (saveTranscript, line 337-339): The empty content check happens before size limit check. Consider reordering so zero-length strings fail fast before Buffer.byteLength calculation (minor optimization).

2. **Console.warn Usage** (transcriptExists, line 461): Uses console.warn for unexpected errors. Consider using a proper logging framework for production environments. Current implementation is acceptable for project scope.

3. **Inconsistent Error Message Format**: Some errors use backticks with template literals, others concatenate strings. Standardize for consistency (style issue, not a bug).

### Security Considerations (Already Handled)

The implementation correctly:

- Validates video IDs before file operations (prevents path traversal)
- Enforces size limits (prevents DoS via large files)
- Uses UTF-8 encoding explicitly (prevents encoding attacks)
- Checks file types before operations (prevents directory deletion)
- Handles permission errors gracefully

### Performance Considerations

The fixes improve performance by:

- Eliminating unnecessary fs.pathExists() calls (BUG-001, BUG-003)
- Removing redundant string matching (BUG-002)
- Reducing syscall count from 3 to 1 in transcriptExists
- Reducing syscall count from 3 to 1 in deleteTranscript
