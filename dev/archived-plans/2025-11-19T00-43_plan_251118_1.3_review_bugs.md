# Remediation Plan: Bug Fixes & Resilience

**Date:** 2025-11-18
**Task Reference:** 1.3 from dev/tasks.md
**Bugs Addressed:** BUG-01 through BUG-10
**Status:** Ready for Implementation

## Plan Overview

Fix 10 critical logical correctness, error handling, and resilience bugs identified in CLI command router, environment loader, validators, and storage service. Bugs range from module loading crashes, race conditions, partial initialization states, to insufficient error reporting and invalid input acceptance.

## High-Level Steps

1. Fix require() error handling in command router (BUG-01)
2. Fix storage initialization atomicity (BUG-07)
3. Add path validation in pathResolver (BUG-08)
4. Fix date validation to reject invalid calendar dates (BUG-05)
5. Add null safety to envLoader.getApiKey() (BUG-04)
6. Remove redundant catch block in bin/transcriptor (BUG-02)
7. Improve error stack logging in asyncHandler (BUG-10)
8. Document validator return value checks (BUG-06)
9. Consolidate command registration timing (BUG-03)
10. Move fs-extra require to module level (BUG-09)

## Detailed Breakdown

### Step 1: Fix require() Error Handling (BUG-01)

#### A. Rationale & Objective

Command handlers loaded via require() can throw synchronous errors if files are missing, deleted, or contain syntax errors. These errors bypass the asyncHandler wrapper because require() executes before the async function runs, causing immediate CLI crashes with unhandled MODULE_NOT_FOUND or SyntaxError exceptions.

#### B. Root Cause Analysis

Lines 47, 55, 63, 71 in src/index.js use require() inside action handlers:

```javascript
.action(asyncHandler(async () => {
    const processCommand = require('./commands/process');
    await processCommand();
}));
```

If `./commands/process.js` is missing, require() throws synchronously. The asyncHandler wrapper catches promise rejections, not synchronous errors during function construction. The require() error propagates before asyncHandler's try-catch executes.

#### C. Recommended Fix Strategy

Wrap each require() in try-catch blocks within the action handlers. If require() fails, throw a descriptive error that asyncHandler will catch. Alternatively, require all command modules at the top of src/index.js before defining actions, causing immediate failure on CLI startup (fail-fast principle).

#### D. Implementation Guide

**Option 1: Wrap require() in try-catch (recommended)**

```javascript
// Before (buggy)
program
  .action(asyncHandler(async () => {
    const processCommand = require('./commands/process');
    await processCommand();
  }));

// After (fixed)
program
  .action(asyncHandler(async () => {
    let processCommand;
    try {
      processCommand = require('./commands/process');
    } catch (error) {
      throw new Error(`Failed to load process command: ${error.message}`);
    }
    await processCommand();
  }));
```

**Option 2: Pre-load all modules at top (alternative, fail-fast)**

```javascript
// At top of src/index.js, before program definition
let processCommand, helpCommand, dataCommand, cleanCommand;
try {
  processCommand = require('./commands/process');
  helpCommand = require('./commands/help');
  dataCommand = require('./commands/data');
  cleanCommand = require('./commands/clean');
} catch (error) {
  console.error('Fatal: Failed to load command modules:', error.message);
  process.exit(1);
}

// Then use directly in actions
program.action(asyncHandler(async () => {
  await processCommand();
}));
```

#### E. Test Cases to Add

```javascript
// Manual test: Rename command file
// mv src/commands/process.js src/commands/process.js.bak
// transcriptor
// Expected: Clear error message about missing module, not raw MODULE_NOT_FOUND

// Manual test: Add syntax error to command file
// echo "invalid javascript {{{" >> src/commands/process.js
// transcriptor
// Expected: Clear error message about module loading failure
```

---

### Step 2: Fix Storage Initialization Atomicity (BUG-07)

#### A. Rationale & Objective

StorageService.initialize() can leave storage in partial state if any operation fails mid-execution. Once this.initialized is false and directories are partially created, subsequent initialize() calls return early (line 26 check), never completing setup. This violates atomicity and causes cascading ENOENT errors in file operations.

#### B. Root Cause Analysis

```javascript
async initialize() {
  if (this.initialized) return; // Line 26: Early return prevents retry

  // Lines 35-36: Partial success possible
  await fs.ensureDir(storagePath);      // Succeeds
  await fs.ensureDir(transcriptsPath);  // Fails (e.g., permission denied)

  // Line 44: Only set if ALL succeed
  this.initialized = true;
}
```

If ensureDir(storagePath) succeeds but ensureDir(transcriptsPath) fails, storagePath directory exists but transcriptsPath doesn't. The catch block throws error, this.initialized remains false. Next initialize() call finds this.initialized=false but checks it BEFORE attempting creation, so it tries again - but the early return at line 26 only checks the flag, not actual filesystem state.

**Correction:** Actually, if this.initialized=false, the early return does NOT execute, so initialization WILL retry. The real bug is different: the catch block at line 45 throws a new error, which propagates to callers. If a caller doesn't handle it properly, the CLI crashes. The this.initialized flag works correctly (only set on full success).

**Re-analysis:** The actual issue is that if initialization fails partway, the error propagates but partial state exists on disk. Subsequent retries might succeed in creating transcriptsPath, but if storagePath creation succeeded previously, re-running ensureDir(storagePath) is redundant (though harmless due to ensureDir idempotency). The bigger issue is error propagation without cleanup - if writeJson fails after directories created, directories remain but registry doesn't exist.

**True root cause:** No atomicity issue with flag, but error handling doesn't clean up partial state. However, fs-extra's ensureDir is idempotent, so retry works. The real bug is if writeJson fails, data.json doesn't exist but directories do, and line 40 check (registryExists) prevents re-initialization on next call because... wait, line 39 checks pathExists, which would return false if file missing, so writeJson would execute again.

**Final analysis:** This is NOT a bug after reviewing fs-extra semantics. ensureDir is idempotent, writeJson is atomic via fs-extra, and the initialized flag correctly prevents redundant work after full success. Marking as FALSE POSITIVE upon deeper analysis. The code is correct.

**Revised assessment:** NO BUG - fs-extra operations are idempotent and the flag logic is sound. Removed from remediation plan.

---

### Step 3: Add Path Validation in pathResolver (BUG-08)

#### A. Rationale & Objective

Path resolver functions return paths without validating that os.homedir() or process.cwd() succeeded. If current working directory is deleted after process starts, process.cwd() throws ENOENT. If home directory unavailable (rare containerized environments), os.homedir() may return null or empty string, creating invalid paths like "null/.transcriptor".

#### B. Root Cause Analysis

```javascript
function getHomePath() {
  return os.homedir(); // No validation - could return null or throw
}

function getLocalTranscriptsPath() {
  return path.resolve(process.cwd(), 'transcripts'); // cwd() can throw
}
```

os.homedir() typically doesn't throw but can return unexpected values. process.cwd() throws if directory deleted. No defensive checks protect callers.

#### C. Recommended Fix Strategy

Add validation to getHomePath() checking for null/empty/undefined. Wrap process.cwd() in getLocalTranscriptsPath() in try-catch, throwing descriptive error if current directory unavailable. This provides fail-fast behavior with clear error messages.

#### D. Implementation Guide

```javascript
// Before (buggy)
function getHomePath() {
  return os.homedir();
}

function getLocalTranscriptsPath() {
  return path.resolve(process.cwd(), 'transcripts');
}

// After (fixed)
function getHomePath() {
  const home = os.homedir();
  if (!home || typeof home !== 'string' || home.trim() === '') {
    throw new Error('Unable to determine home directory - HOME environment variable not set');
  }
  return home;
}

function getLocalTranscriptsPath() {
  let cwd;
  try {
    cwd = process.cwd();
  } catch (error) {
    throw new Error(`Unable to access current directory: ${error.message}. Directory may have been deleted.`);
  }
  return path.resolve(cwd, 'transcripts');
}
```

#### E. Test Cases to Add

```javascript
// Manual test: Delete current directory while process running
// In terminal 1: cd /tmp/testdir && node -e "require('./pathResolver').getLocalTranscriptsPath()"
// In terminal 2: rm -rf /tmp/testdir
// Expected: Clear error about directory deletion, not raw ENOENT

// Manual test: Unset HOME
// env -u HOME node -e "require('./pathResolver').getHomePath()"
// Expected: Clear error about missing HOME variable
```

---

### Step 4: Fix Date Validation (BUG-05)

#### A. Rationale & Objective

isValidDate() in validators.js uses new Date(dateString) which silently coerces invalid calendar dates. "2024-02-31" passes regex validation then JavaScript Date constructor coerces it to "2024-03-02". The clean command could delete transcripts from wrong dates if users provide invalid dates that get coerced.

#### B. Root Cause Analysis

```javascript
function isValidDate(dateString) {
  if (typeof dateString !== 'string') return false;

  // Regex checks format but not validity
  if (!/^\d{4}-\d{2}-\d{2}$/.test(dateString)) return false;

  // Date constructor coerces invalid dates
  const date = new Date(dateString);
  return date instanceof Date && !isNaN(date.getTime());
}
```

Test case "2024-02-31":
- Passes regex (format correct)
- new Date("2024-02-31") returns Date object for 2024-03-02
- !isNaN(date.getTime()) is true (valid timestamp)
- Function returns true (INCORRECT)

#### C. Recommended Fix Strategy

Parse year, month, day components from string. Validate month in 1-12 range, day in 1-31 range. Create Date object from components. Verify Date's getMonth() and getDate() match input values - if JavaScript coerced the date, they won't match. This detects "2024-02-31" because constructed Date would have getMonth()=2 (March) not 1 (February).

#### D. Implementation Guide

```javascript
// Before (buggy)
function isValidDate(dateString) {
  if (typeof dateString !== 'string') return false;

  // Check format
  if (!/^\d{4}-\d{2}-\d{2}$/.test(dateString)) return false;

  // Check date is valid (not 2024-99-99)
  const date = new Date(dateString);
  return date instanceof Date && !isNaN(date.getTime());
}

// After (fixed)
function isValidDate(dateString) {
  if (typeof dateString !== 'string') return false;

  // Check format
  const match = /^(\d{4})-(\d{2})-(\d{2})$/.exec(dateString);
  if (!match) return false;

  // Parse components
  const year = parseInt(match[1], 10);
  const month = parseInt(match[2], 10);
  const day = parseInt(match[3], 10);

  // Validate ranges
  if (month < 1 || month > 12) return false;
  if (day < 1 || day > 31) return false;

  // Create date and verify no coercion occurred
  const date = new Date(year, month - 1, day); // month is 0-indexed

  // If JavaScript coerced date, components won't match
  if (date.getFullYear() !== year) return false;
  if (date.getMonth() !== month - 1) return false;
  if (date.getDate() !== day) return false;

  return !isNaN(date.getTime());
}
```

#### E. Test Cases to Add

```javascript
test('rejects February 31st', () => {
  expect(isValidDate('2024-02-31')).toBe(false);
});

test('rejects February 30th', () => {
  expect(isValidDate('2024-02-30')).toBe(false);
});

test('accepts February 29th in leap year', () => {
  expect(isValidDate('2024-02-29')).toBe(true);
});

test('rejects February 29th in non-leap year', () => {
  expect(isValidDate('2023-02-29')).toBe(false);
});

test('rejects month 13', () => {
  expect(isValidDate('2024-13-01')).toBe(false);
});

test('rejects day 32', () => {
  expect(isValidDate('2024-01-32')).toBe(false);
});

test('accepts valid date', () => {
  expect(isValidDate('2024-12-31')).toBe(true);
});
```

---

### Step 5: Add Null Safety to envLoader.getApiKey() (BUG-04)

#### A. Rationale & Objective

getApiKey() returns process.env.SCRAPE_CREATORS_API_KEY without checking if validate() executed. When NODE_ENV=structure-test, validation skips (line 44), leaving API key potentially undefined. APIClient constructor receives undefined, causing silent API request failures with 401 errors instead of clear configuration errors.

#### B. Root Cause Analysis

```javascript
// envLoader.js
function load() {
  // ...
  if (process.env.NODE_ENV !== 'structure-test') {
    validate(); // Only validates if NOT in test mode
  }
}

function getApiKey() {
  return process.env.SCRAPE_CREATORS_API_KEY; // Could be undefined in test mode
}

// APIClient.js
constructor(apiKey) {
  this.apiKey = apiKey; // Accepts undefined without validation
}
```

In structure-test mode, SCRAPE_CREATORS_API_KEY may be unset. getApiKey() returns undefined. API requests fail later with cryptic 401 errors instead of immediate clear message about missing key.

#### C. Recommended Fix Strategy

Add explicit check in getApiKey() that API key exists and is non-empty string. If missing, throw descriptive error explaining key required even in test environments for API operations. Alternatively, accept undefined for test mode but document it clearly, requiring callers to handle undefined.

**Better approach:** Check in APIClient constructor - if apiKey undefined/empty, throw immediately with clear message. This enforces validation at point of use.

#### D. Implementation Guide

```javascript
// Option 1: Fix in envLoader (recommended)
function getApiKey() {
  const key = process.env.SCRAPE_CREATORS_API_KEY;
  if (!key || typeof key !== 'string' || key.trim() === '') {
    throw new Error(
      'SCRAPE_CREATORS_API_KEY not set. ' +
      'This is required even in test environments when making API calls. ' +
      'Add it to your .env file.'
    );
  }
  return key;
}

// Option 2: Fix in APIClient constructor (alternative)
constructor(apiKey) {
  if (!apiKey || typeof apiKey !== 'string' || apiKey.trim() === '') {
    throw new Error(
      'API key is required. Ensure SCRAPE_CREATORS_API_KEY is set in .env file.'
    );
  }
  this.apiKey = apiKey;
  this.baseURL = 'https://api.scrape-creators.com';
  this.timeout = 30000;
}
```

#### E. Test Cases to Add

```javascript
// Manual test: Run in structure-test mode without API key
// NODE_ENV=structure-test SCRAPE_CREATORS_API_KEY= node -e "require('./envLoader').getApiKey()"
// Expected: Clear error about missing API key

// Unit test
test('getApiKey throws if key not set', () => {
  delete process.env.SCRAPE_CREATORS_API_KEY;
  expect(() => envLoader.getApiKey()).toThrow('SCRAPE_CREATORS_API_KEY not set');
});

test('APIClient constructor throws if apiKey undefined', () => {
  expect(() => new APIClient(undefined)).toThrow('API key is required');
});
```

---

### Step 6: Remove Redundant Catch Block (BUG-02)

#### A. Rationale & Objective

bin/transcriptor has redundant error handling. envLoader.load() already calls process.exit(1) on errors (lines 31, 39, 67 in envLoader.js). The catch block at line 20 in bin/transcriptor executes process.exit(1) without logging if envLoader throws instead of exiting. This creates silent failure - users see no error message if envLoader unexpectedly throws.

#### B. Root Cause Analysis

```javascript
// bin/transcriptor
try {
  envLoader.load();
} catch (error) {
  // Error handling is in envLoader, this catch prevents crashes
  process.exit(1); // Silent exit - no error logged
}
```

envLoader.load() calls process.exit(1) directly on errors, so catch block normally never executes. However, if envLoader.load() is modified to throw errors instead of exiting, catch block suppresses error silently. Comment suggests error handling delegated to envLoader, but catch block contradicts this by swallowing exceptions.

#### C. Recommended Fix Strategy

**Option 1:** Remove catch block entirely - let envLoader.load() handle all errors and exit. If it throws unexpectedly, let error propagate to crash with stack trace (better for debugging).

**Option 2:** Keep catch but log error before exit:

```javascript
try {
  envLoader.load();
} catch (error) {
  console.error('Fatal error loading environment:', error.message);
  if (process.env.DEBUG) {
    console.error(error.stack);
  }
  process.exit(1);
}
```

Recommend Option 1 for simplicity since envLoader already handles errors.

#### D. Implementation Guide

```javascript
// Before (buggy)
try {
  envLoader.load();
} catch (error) {
  // Error handling is in envLoader, this catch prevents crashes
  process.exit(1);
}

// After (fixed) - Option 1
envLoader.load();

// After (fixed) - Option 2
try {
  envLoader.load();
} catch (error) {
  console.error('Fatal error loading environment:', error.message);
  process.exit(1);
}
```

#### E. Test Cases to Add

```javascript
// Manual test: Modify envLoader to throw instead of exit
// In envLoader.load(), replace process.exit(1) with throw new Error('test')
// Run: transcriptor
// Expected: Error message visible, not silent exit
```

---

### Step 7: Improve Error Stack Logging (BUG-10)

#### A. Rationale & Objective

asyncHandler in src/index.js only logs error.stack when process.env.DEBUG is set. In production without DEBUG, users see only error.message. Many errors are useless without stack traces (e.g., "Cannot read property 'x' of undefined" doesn't indicate location). Users can't provide actionable bug reports. DEBUG environment variable is undocumented - users won't know to set it.

#### B. Root Cause Analysis

```javascript
function asyncHandler(fn) {
  return async function(...args) {
    try {
      await fn(...args);
    } catch (error) {
      console.error('Error:', error.message);
      if (process.env.DEBUG) { // Only shows stack if DEBUG set
        console.error(error.stack);
      }
      process.exit(1);
    }
  };
}
```

Production errors show only message, hiding critical debugging information. Environment variable gating is non-standard - most CLI tools show stack traces by default or via --verbose flag.

#### C. Recommended Fix Strategy

**Option 1:** Always log stack trace to stderr for all errors. Stack traces are for developers/debugging, not sensitive information. Users can share them in bug reports.

**Option 2:** Add --verbose or --debug CLI flag (via commander) instead of environment variable. More discoverable and standard CLI practice.

Recommend Option 1 for simplicity - CLI tools typically show full stack traces.

#### D. Implementation Guide

```javascript
// Before (buggy)
function asyncHandler(fn) {
  return async function(...args) {
    try {
      await fn(...args);
    } catch (error) {
      console.error('Error:', error.message);
      if (process.env.DEBUG) {
        console.error(error.stack);
      }
      process.exit(1);
    }
  };
}

// After (fixed) - Option 1
function asyncHandler(fn) {
  return async function(...args) {
    try {
      await fn(...args);
    } catch (error) {
      console.error('Error:', error.message);
      console.error(error.stack); // Always show stack
      process.exit(1);
    }
  };
}

// After (fixed) - Option 2 (if adding --verbose flag)
// In program configuration section:
program.option('-v, --verbose', 'Show detailed error information');

// In asyncHandler:
function asyncHandler(fn) {
  return async function(...args) {
    try {
      await fn(...args);
    } catch (error) {
      console.error('Error:', error.message);
      if (program.opts().verbose) {
        console.error(error.stack);
      }
      process.exit(1);
    }
  };
}
```

#### E. Test Cases to Add

```javascript
// Manual test: Trigger error without DEBUG
// Create youtube.md with invalid content that causes processing error
// Run: transcriptor
// Expected: Full stack trace visible

// Manual test: Verify verbose flag (if Option 2)
// Run: transcriptor --verbose
// Expected: Stack traces shown
```

---

### Step 8: Document Validator Return Value Checks (BUG-06)

#### A. Rationale & Objective

isValidVideoId() and isValidDate() return false for invalid inputs but provide no enforcement mechanism. Future code calling these validators might not check return values, allowing invalid data to proceed until causing crashes later. This is a documentation and usage pattern issue rather than code bug, but requires preventive action.

#### B. Root Cause Analysis

```javascript
function isValidVideoId(id) {
  if (typeof id !== 'string') return false;
  return /^[A-Za-z0-9_-]{11}$/.test(id);
}
```

Callers like:
```javascript
const videoId = extractIdFromUrl(url);
isValidVideoId(videoId); // Returns false, but execution continues
processVideo(videoId); // Processes invalid ID, crashes later
```

No compile-time or runtime enforcement that return value must be checked.

#### C. Recommended Fix Strategy

**Option 1:** Add JSDoc @throws annotation and create assertValid* wrapper functions that throw on invalid input. Use these in critical paths.

**Option 2:** Add validateOrThrow option parameter to validators - if true, throw instead of returning false.

**Option 3:** Document clearly in JSDoc that callers MUST check return value, with usage examples.

Recommend combination of Options 1 and 3 for clarity and safety.

#### D. Implementation Guide

```javascript
// Add to validators.js

/**
 * Validate YouTube video ID format (non-throwing)
 * Per TR-5: 11 characters, alphanumeric + dash + underscore
 *
 * @param {string} id - Video ID to validate
 * @returns {boolean} True if valid format, false otherwise
 *
 * @example
 * if (!isValidVideoId(id)) {
 *   throw new Error('Invalid video ID format');
 * }
 */
function isValidVideoId(id) {
  if (typeof id !== 'string') return false;
  return /^[A-Za-z0-9_-]{11}$/.test(id);
}

/**
 * Assert video ID is valid, throwing if not
 *
 * @param {string} id - Video ID to validate
 * @throws {Error} If ID format invalid
 * @returns {void}
 *
 * @example
 * assertValidVideoId(id); // Throws if invalid
 * processVideo(id);       // Safe to proceed
 */
function assertValidVideoId(id) {
  if (!isValidVideoId(id)) {
    throw new Error(
      `Invalid video ID format: "${id}". ` +
      'Expected 11 alphanumeric characters, dashes, or underscores.'
    );
  }
}

/**
 * Assert date string is valid, throwing if not
 *
 * @param {string} dateString - Date string to validate
 * @throws {Error} If date format invalid
 * @returns {void}
 */
function assertValidDate(dateString) {
  if (!isValidDate(dateString)) {
    throw new Error(
      `Invalid date format: "${dateString}". ` +
      'Expected YYYY-MM-DD with valid calendar date.'
    );
  }
}

module.exports = {
  isValidVideoId,
  isValidDate,
  sanitizeVideoId,
  assertValidVideoId, // Export new helpers
  assertValidDate
};
```

#### E. Test Cases to Add

```javascript
test('assertValidVideoId throws for invalid ID', () => {
  expect(() => assertValidVideoId('invalid')).toThrow('Invalid video ID format');
});

test('assertValidVideoId does not throw for valid ID', () => {
  expect(() => assertValidVideoId('dQw4w9WgXcQ')).not.toThrow();
});

test('assertValidDate throws for invalid date', () => {
  expect(() => assertValidDate('2024-02-31')).toThrow('Invalid date format');
});

test('assertValidDate does not throw for valid date', () => {
  expect(() => assertValidDate('2024-02-29')).not.toThrow();
});
```

---

### Step 9: Consolidate Command Registration Timing (BUG-03)

#### A. Rationale & Objective

Command handlers register via .action() calls (lines 47-78) synchronously, then IIFE at lines 84-91 runs parseAsync(). While unlikely with current code, if registration is asynchronous in future refactoring or if main thread blocked, parseAsync() might start before all handlers registered. Error handling split between asyncHandler (individual commands) and IIFE catch block (parse errors) creates confusing flow.

#### B. Root Cause Analysis

```javascript
// Lines 47-78: Command registration
program.action(asyncHandler(async () => { ... }));
program.command('help').action(() => { ... });
program.command('data').action(asyncHandler(async () => { ... }));
program.command('clean <date>').action(asyncHandler(async (date) => { ... }));

// Lines 84-91: Parsing starts immediately
(async () => {
  try {
    await program.parseAsync(process.argv);
  } catch (error) {
    console.error('Fatal error:', error.message);
    process.exit(1);
  }
})();
```

All .action() calls are synchronous, so registration completes before IIFE executes. However, this is implicit - code structure doesn't guarantee ordering. If future developer adds async registration, race condition possible.

Error handling uses two mechanisms:
1. asyncHandler catches errors in command implementations
2. IIFE catch block catches commander parsing errors

This works correctly but is confusing to maintain.

#### C. Recommended Fix Strategy

**Option 1:** Add comment documenting that registration must complete before parseAsync().

**Option 2:** Wrap all registration in explicit setup function, call before parseAsync().

**Option 3:** Consolidate error handling - let asyncHandler handle all errors, remove IIFE catch.

Recommend Option 2 for clarity and future-proofing.

#### D. Implementation Guide

```javascript
// Before (implicit ordering)
program.action(asyncHandler(async () => { ... }));
program.command('help').action(() => { ... });
// ... more commands

(async () => {
  try {
    await program.parseAsync(process.argv);
  } catch (error) {
    console.error('Fatal error:', error.message);
    process.exit(1);
  }
})();

// After (explicit setup)
function setupCommands() {
  // Default action: process youtube.md file in current directory
  program.action(asyncHandler(async () => {
    const processCommand = require('./commands/process');
    await processCommand();
  }));

  // Help command
  program
    .command('help')
    .description('Display detailed usage information')
    .action(() => {
      const helpCommand = require('./commands/help');
      helpCommand();
    });

  // Data statistics command
  program
    .command('data')
    .description('Display repository statistics and metrics')
    .action(asyncHandler(async () => {
      const dataCommand = require('./commands/data');
      await dataCommand();
    }));

  // Clean command
  program
    .command('clean <date>')
    .description('Remove transcripts older than specified date (YYYY-MM-DD)')
    .action(asyncHandler(async (date) => {
      const cleanCommand = require('./commands/clean');
      await cleanCommand(date);
    }));
}

// Ensure commands registered before parsing
(async () => {
  try {
    setupCommands(); // Explicit registration
    await program.parseAsync(process.argv);
  } catch (error) {
    console.error('Fatal error:', error.message);
    process.exit(1);
  }
})();
```

#### E. Test Cases to Add

```javascript
// Manual test: Verify all commands available
// transcriptor help
// transcriptor data
// transcriptor clean 2024-01-01
// Expected: All commands execute without "unknown command" errors
```

---

### Step 10: Move fs-extra Require to Module Level (BUG-09)

#### A. Rationale & Objective

StorageService.js requires fs-extra inside initialize() method (line 28) instead of module top. While Node.js caches requires, this pattern is inefficient and inconsistent. More critically, if fs-extra missing from node_modules, error only thrown when initialize() called, delaying detection. Module-level require fails immediately on import, enabling fail-fast.

#### B. Root Cause Analysis

```javascript
class StorageService {
  async initialize() {
    const fs = require('fs-extra'); // Inside method
    // ...
  }
}
```

Every initialize() call re-executes require('fs-extra'). If fs-extra uninstalled, error occurs late in execution rather than at module load time.

#### C. Recommended Fix Strategy

Move require to top of file with other requires. This is standard Node.js practice - all dependencies loaded at module initialization for immediate failure detection and consistency.

#### D. Implementation Guide

```javascript
// Before (buggy)
class StorageService {
  async initialize() {
    const fs = require('fs-extra');
    const storagePath = this.paths.getStoragePath();
    // ...
  }
}

// After (fixed)
const fs = require('fs-extra'); // Move to top of file

class StorageService {
  async initialize() {
    const storagePath = this.paths.getStoragePath();
    const transcriptsPath = this.paths.getTranscriptsPath();
    const registryPath = this.paths.getRegistryPath();

    try {
      await fs.ensureDir(storagePath);
      await fs.ensureDir(transcriptsPath);
      // ... rest of method
    } catch (error) {
      console.error('Failed to initialize storage:', error.message);
      throw new Error(`Storage initialization failed: ${error.message}`);
    }
  }
}
```

#### E. Test Cases to Add

```javascript
// Manual test: Remove fs-extra
// npm uninstall fs-extra
// node -e "require('./src/services/StorageService')"
// Expected: Immediate MODULE_NOT_FOUND error, not delayed error
```

---

## Validation Checklist

- [ ] BUG-01: require() calls wrapped in error handling
- [ ] BUG-03: Command registration timing explicitly controlled
- [ ] BUG-04: getApiKey() validates key exists before returning
- [ ] BUG-05: Date validation rejects invalid calendar dates (Feb 31, etc)
- [ ] BUG-06: assertValid* helper functions added and documented
- [ ] BUG-08: Path resolver validates homedir and cwd before use
- [ ] BUG-09: fs-extra required at module level in StorageService
- [ ] BUG-10: Error stack traces always logged (or --verbose flag added)
- [ ] BUG-02: Redundant catch block removed or logged properly
- [ ] All manual test scenarios pass
- [ ] No new bugs introduced
- [ ] Error messages clear and actionable

## Implementation Notes

**Priority order:**
1. BUG-01 (require crashes) - CRITICAL
2. BUG-08 (path validation) - HIGH
3. BUG-05 (date validation) - HIGH
4. BUG-04 (API key null check) - HIGH
5. BUG-10 (error logging) - MEDIUM
6. BUG-06 (validator docs) - MEDIUM
7. BUG-02, BUG-03, BUG-09 - LOW priority cleanup

**Testing approach:**
- Manual testing required for most bugs (no test infrastructure per requirements)
- Focus on error path testing - delete files, corrupt data, invalid inputs
- Verify error messages are clear and actionable

**Regression risks:**
- BUG-05 date validation change might break existing behavior if code relies on coercion
- BUG-01 require error handling adds overhead to command loading
- BUG-10 always-on stack traces may expose internal paths (minor security consideration)

**Dependencies:**
- No external dependency changes required
- All fixes use existing Node.js/npm packages
- Changes isolated to identified files
