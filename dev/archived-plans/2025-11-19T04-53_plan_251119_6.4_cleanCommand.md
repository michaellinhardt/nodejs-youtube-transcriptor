# Implementation Plan: 6.4 - Clean Command

**Version:** 2.0 (Reviewed)
**Original Date:** 2025-11-19
**Revision Date:** 2025-11-19
**Review Status:** REVIEWED_AND_ENHANCED
**Task:** 6.4 - Clean command (implements FR-6, TR-4)
**Status:** Ready for Implementation
**Requirements:** FR-6, FR-6.1, FR-6.2, FR-8.4, FR-9.1, FR-10, FR-10.1, FR-10.2, BR-3, BR-4, TR-4, TR-13

## Plan Overview

This plan implements the `transcriptor clean YYYY-MM-DD` command that removes transcripts older than a specified date boundary. The feature provides controlled data lifecycle management, allowing users to reclaim storage space while preserving recent or actively-used transcripts. The implementation follows an atomic, fail-safe approach where each transcript deletion completes fully before proceeding to the next, ensuring data integrity even during interruptions. The command processes each qualifying entry by deleting all symbolic links, removing the transcript file, removing the registry entry, and saving the updated registry atomically. The date boundary is exclusive (transcripts from the specified date are kept, only older ones are removed), aligned with FR-6.1 and BR-4 specifications.

## Tasks Planned

- 6.4 Clean command (implements FR-6, TR-4)
  - 6.4.1 Parse and validate date input
  - 6.4.2 Filter transcripts by date (exclusive)
  - 6.4.3 Delete transcript files and links
  - 6.4.4 Update registry after cleanup

## High-Level Steps

1. Validate and parse date input parameter
2. Load registry and filter transcripts by date
3. Delete each transcript atomically (links, file, registry entry)
4. Display cleanup summary statistics
5. Handle errors gracefully with fail-safe continuation

## Detailed Implementation

### Step 1: Date Validation and Parsing

#### A. Rationale & Objective

Validate user-provided date input before any operations commence. Ensures date format matches YYYY-MM-DD specification (BR-4) and represents a valid calendar date. Early validation prevents wasted operations and provides clear error feedback.

#### B. Core Concepts & Strategy

- Leverage existing `validators.assertValidDate()` utility (already validates format and calendar)
- Parse date string into Date object for comparison operations
- Validate date is not in the future (optional guard against user error)
- Set exclusive boundary semantics: transcripts WITH this date are kept, older are removed

**Date Comparison Strategy:**
```text
Registry Entry Date    Boundary Date    Action
-------------------    -------------    ------
2025-11-15            2025-11-18       DELETE (older)
2025-11-18            2025-11-18       KEEP (equals boundary)
2025-11-19            2025-11-18       KEEP (newer)
```

#### C. Implementation Guidelines

**Key Logic:**

```javascript
// In cleanCommand(dateString)
const validators = require('../utils/validators');

// Guard: Validate date format early
try {
  validators.assertValidDate(dateString);
} catch (error) {
  console.error('Invalid date format:', error.message);
  console.error('Usage: transcriptor clean YYYY-MM-DD');
  console.error('Example: transcriptor clean 2025-11-01');
  process.exit(2); // Exit code 2: Validation failure
}

// Parse into Date object for comparisons
const boundaryDate = new Date(dateString);

// Optional: Warn if future date provided
const today = new Date();
today.setHours(0, 0, 0, 0);
if (boundaryDate > today) {
  console.warn('Warning: Boundary date is in the future');
  console.warn('This will not delete any transcripts');
}
```

**Critical Points:**

- Use `assertValidDate()` from validators.js (already exists and handles edge cases)
- Date comparison uses ISO date strings for consistency (YYYY-MM-DD format)
- Exclusive boundary: `<` operator, not `<=` (aligns with FR-6.1)
- Handle invalid format gracefully with clear error message and usage example

#### D. Success Criteria

- [ ] Date string validated against YYYY-MM-DD format
- [ ] Invalid dates (e.g., "2025-02-31") rejected with clear error
- [ ] Invalid formats (e.g., "11/19/2025") rejected with usage guidance
- [ ] Date successfully parsed into Date object for comparisons
- [ ] User receives clear error message and usage example on validation failure

#### E. Dependencies & Inputs

- Requires: `validators.assertValidDate()`, `validators.isValidDate()` from utils/validators.js
- Input: `dateString` parameter from command-line argument
- Produces: Validated `boundaryDate` (Date object) for filtering step

---

### Step 2: Load Registry and Filter Transcripts

#### A. Rationale & Objective

Load complete registry and identify transcripts eligible for deletion based on date boundary. Apply exclusive filtering logic (keep boundary date, delete older) per FR-6.1. Build deletion candidates list for atomic processing.

#### B. Core Concepts & Strategy

- Load registry using StorageService (already implements FR-3.2, TR-16)
- Filter entries where `date_added < boundaryDate` (exclusive boundary)
- Track statistics: total count, eligible count, skipped count
- Handle empty registry gracefully (no-op success case)
- Validate registry entry structure during filtering

**Filtering Algorithm:**
```text
FOR EACH entry IN registry:
  IF entry.date_added < boundary_date:
    ADD to deletion_candidates
  ELSE:
    INCREMENT skipped_count

RETURN deletion_candidates, statistics
```

#### C. Implementation Guidelines

**Key Logic:**

```javascript
const StorageService = require('../services/StorageService');
const pathResolver = require('../utils/pathResolver');

// Initialize storage
const storage = new StorageService(pathResolver);
await storage.initialize();

// Load registry
let registry;
try {
  registry = await storage.loadRegistry();
} catch (error) {
  console.error('Failed to load registry:', error.message);
  if (error.message.includes('corrupted')) {
    console.error('Registry file is corrupted. Manual cleanup may be required.');
  }
  process.exit(1);
}

// Guard: Handle empty registry
if (Object.keys(registry).length === 0) {
  console.log('No transcripts found in registry. Nothing to clean.');
  return;
}

// Filter transcripts by date (exclusive boundary)
const deletionCandidates = [];
let skippedCount = 0;
let corruptedCount = 0;

for (const [videoId, entry] of Object.entries(registry)) {
  // Guard: Validate entry structure completely
  const validationResult = validateRegistryEntry(videoId, entry);
  if (!validationResult.valid) {
    console.warn(`Skipping corrupted entry: ${videoId} - ${validationResult.reason}`);
    corruptedCount++;
    continue;
  }

  // Compare dates as strings (YYYY-MM-DD lexicographic comparison works)
  if (entry.date_added < dateString) {
    deletionCandidates.push({ videoId, entry });
  } else {
    skippedCount++;
  }
}

// Guard: Nothing to delete
if (deletionCandidates.length === 0) {
  console.log(`No transcripts older than ${dateString}. Nothing to clean.`);
  console.log(`Total transcripts: ${Object.keys(registry).length}`);
  if (corruptedCount > 0) {
    console.warn(`Warning: ${corruptedCount} corrupted entries skipped (run data command for details)`);
  }
  return;
}

console.log(`\nFound ${deletionCandidates.length} transcripts older than ${dateString}`);
console.log(`Keeping ${skippedCount} transcripts (boundary date or newer)`);
if (corruptedCount > 0) {
  console.warn(`Skipped ${corruptedCount} corrupted entries`);
}
console.log('');
```

**Helper Function for Registry Validation:**

```javascript
/**
 * Validate registry entry structure for filtering
 * @param {string} videoId - Video ID
 * @param {*} entry - Registry entry to validate
 * @returns {Object} { valid: boolean, reason?: string }
 */
function validateRegistryEntry(videoId, entry) {
  const validators = require('../utils/validators');

  // Guard: Entry exists and is object
  if (!entry || typeof entry !== 'object') {
    return { valid: false, reason: 'Entry is null or not an object' };
  }

  // Guard: date_added field exists and is non-empty string
  if (!entry.date_added || typeof entry.date_added !== 'string' || entry.date_added.trim() === '') {
    return { valid: false, reason: 'Missing or invalid date_added field' };
  }

  // Guard: date_added format valid (YYYY-MM-DD per BR-4)
  if (!validators.isValidDate(entry.date_added)) {
    return { valid: false, reason: `Invalid date format: ${entry.date_added}` };
  }

  // Guard: links field exists and is array
  if (!Array.isArray(entry.links)) {
    return { valid: false, reason: 'Missing or invalid links field' };
  }

  return { valid: true };
}
```

**Critical Points:**

- String comparison works for YYYY-MM-DD format (`"2025-11-15" < "2025-11-18"` is true)
- Exclusive boundary: `<` operator matches FR-6.1 specification
- Comprehensive entry validation during filtering prevents processing corrupted data (defensive programming per FR-10.2)
- Track corrupted entries separately and report to user
- Display clear statistics before deletion begins including corruption warnings
- Handle empty registry as success case (idempotent operation)
- Helper function ensures consistent validation logic across filtering step

#### D. Success Criteria

- [ ] Registry loaded successfully with error handling
- [ ] Corrupted registry detected and reported clearly
- [ ] Empty registry handled as no-op success case
- [ ] Transcripts filtered correctly using exclusive date boundary
- [ ] Invalid entries (missing date_added) skipped with warning
- [ ] Entries with invalid date formats skipped with descriptive warning
- [ ] Entries with empty string date_added skipped
- [ ] Entries with null/undefined values skipped
- [ ] Statistics displayed: total found, eligible for deletion, kept, corrupted
- [ ] Zero eligible transcripts handled gracefully (no-op message)
- [ ] Corrupted entry count displayed to user if non-zero

#### E. Dependencies & Inputs

- Requires: StorageService initialized, validated `dateString` from Step 1
- Input: Registry data (Object with videoId keys)
- Produces: `deletionCandidates` array (contains { videoId, entry } objects), `skippedCount`

---

### Step 3: Delete Transcripts Atomically

#### A. Rationale & Objective

Delete each transcript completely following atomic per-entry processing pattern (FR-6.2). For each candidate: delete all symbolic links, delete transcript file, remove registry entry, save updated registry. Process sequentially with fail-safe error handling (FR-10.1) to ensure completed deletions persist even if later operations fail.

#### B. Core Concepts & Strategy

- Process one transcript at a time (sequential atomic operations per FR-6.2)
- Use LinkManager.removeAllLinks() to delete symbolic links (already exists)
- Use StorageService.deleteTranscript() to remove file (already exists)
- Remove registry entry and save immediately (atomic write per FR-9.1)
- Continue on individual failures (fail-safe per FR-10.1, FR-10.2)
- Track detailed statistics: success, errors, link removals

**Processing Workflow per FR-6.2:**
```text
FOR EACH candidate IN deletion_candidates:
  TRY:
    1. Delete all symbolic links (via LinkManager)
    2. Delete transcript file (via StorageService)
    3. Remove registry entry
    4. Save registry atomically
    5. Increment success_count
  CATCH:
    Log error details
    Increment error_count
    Continue to next candidate
```

#### C. Implementation Guidelines

**Key Logic:**

```javascript
const LinkManager = require('../services/LinkManager');

// Initialize dependencies
const linkManager = new LinkManager(storage, pathResolver);

// Track results
const results = {
  total: deletionCandidates.length,
  success: 0,
  errors: [],
  linksRemoved: 0,
  linksSkipped: 0
};

// Process each transcript atomically with progress reporting
let processedCount = 0;
for (const { videoId, entry } of deletionCandidates) {
  processedCount++;
  const progress = `[${processedCount}/${results.total}]`;

  try {
    console.log(`${progress} Deleting: ${videoId} (added ${entry.date_added})`);

    // 1. Delete all symbolic links
    const linkResults = await linkManager.removeAllLinks(videoId);
    results.linksRemoved += linkResults.removed;
    results.linksSkipped += linkResults.skipped;

    if (linkResults.errors && linkResults.errors.length > 0) {
      console.warn(`  Warning: Some links could not be removed for ${videoId}`);
      linkResults.errors.forEach(err => {
        console.warn(`    ${err.path}: ${err.error}`);
      });
    }

    // 2. Delete transcript file
    try {
      await storage.deleteTranscript(videoId);
    } catch (deleteError) {
      // Handle ENOENT gracefully (file already deleted)
      if (deleteError.message.includes('Transcript not found')) {
        console.warn(`  Warning: Transcript file already deleted: ${videoId}`);
      } else {
        throw deleteError;
      }
    }

    // 3. Remove registry entry
    delete registry[videoId];

    // 4. Save registry atomically (implements FR-9.1)
    await storage.saveRegistry(registry);

    results.success++;
    console.log(`  ✓ Deleted successfully`);

  } catch (error) {
    // Fail-safe: Log error and continue (FR-10.1)
    console.error(`  ✗ Error deleting ${videoId}: ${error.message}`);
    results.errors.push({
      videoId,
      error: error.message,
      date_added: entry.date_added
    });
  }
}
```

**Critical Points:**

- Sequential processing ensures atomic per-entry operations (FR-6.2)
- LinkManager.removeAllLinks() handles link deletion with built-in error handling
- StorageService.deleteTranscript() is idempotent (ENOENT safe)
- Registry saved after EACH successful deletion (crash-resilient per FR-9.2)
- Continue on errors (fail-safe pattern per FR-10.1)
- Track detailed error information for summary display

#### D. Success Criteria

- [ ] Each transcript processed atomically (links, file, registry, save)
- [ ] Progress indicator displayed for each deletion (e.g., [1/5], [2/5])
- [ ] Symbolic links deleted using LinkManager.removeAllLinks()
- [ ] Transcript files deleted using StorageService.deleteTranscript()
- [ ] Registry entry removed and saved after each deletion
- [ ] Individual errors logged but processing continues
- [ ] Missing files handled gracefully (ENOENT as warning, not error)
- [ ] Link deletion errors reported but don't halt transcript deletion
- [ ] Statistics tracked: success count, error count, links removed/skipped
- [ ] Real-time progress updates provide user feedback during long operations

#### E. Dependencies & Inputs

- Requires: LinkManager initialized, `deletionCandidates` array from Step 2, `registry` object
- Input: Array of { videoId, entry } objects to delete
- Produces: Updated `registry` (persisted after each deletion), `results` object with statistics

---

### Step 4: Display Cleanup Summary

#### A. Rationale & Objective

Provide comprehensive feedback to user about cleanup operation results. Display success count, error count, links removed, and storage reclaimed. Format output consistently with existing commands (data.js, process.js) for user experience continuity.

#### B. Core Concepts & Strategy

- Calculate storage reclaimed (optional enhancement)
- Display summary statistics matching process.js output format
- Show errors encountered (if any) with actionable context
- Provide clear success message or error guidance
- Use consistent formatting with other commands (=== headers, blank lines)

#### C. Implementation Guidelines

**Key Logic:**

```javascript
// Display summary
console.log('\n=== Cleanup Summary ===\n');
console.log(`Total transcripts processed: ${results.total}`);
console.log(`Successfully deleted:        ${results.success}`);
console.log(`Failed to delete:            ${results.errors.length}`);
console.log(`Symbolic links removed:      ${results.linksRemoved}`);
console.log(`Symbolic links skipped:      ${results.linksSkipped}`);

// Show errors if any
if (results.errors.length > 0) {
  console.log('\nErrors encountered:');
  results.errors.forEach(err => {
    console.log(`  ${err.videoId} (${err.date_added}): ${err.error}`);
  });
  console.log('\nTranscripts with errors remain in the registry.');
  console.log('Review errors and run clean command again if needed.');
}

// Final status
console.log('');
if (results.errors.length === 0) {
  console.log('Cleanup completed successfully.');
} else {
  console.log('Cleanup completed with errors (see above).');
}
```

**Critical Points:**

- Match output format of data.js and process.js (=== headers, aligned columns)
- Display all statistics even if zero (clear status reporting)
- Error details include videoId and date for user context
- Guidance provided for error resolution
- Blank lines for readability (consistent with other commands)

#### D. Success Criteria

- [ ] Summary statistics displayed clearly
- [ ] Output format consistent with data.js and process.js commands
- [ ] Errors listed with videoId, date, and error message
- [ ] Clear guidance provided when errors occur
- [ ] Success vs. partial success clearly indicated
- [ ] Blank lines used for readability

#### E. Dependencies & Inputs

- Requires: `results` object from Step 3
- Input: Statistics from deletion operations
- Produces: Formatted console output

---

### Step 5: Error Handling and Edge Cases

#### A. Rationale & Objective

Implement comprehensive error handling across all failure modes. Handle missing resources gracefully (FR-10.2), validate inputs defensively, provide clear error messages, and ensure operation is safe and idempotent.

#### B. Core Concepts & Strategy

- Command-level try-catch for unexpected errors
- Validate all inputs before operations
- Handle missing files/links as warnings, not errors
- Provide actionable error messages with context
- Exit with appropriate status codes (0 success, 1 error)

**Error Categories:**
1. **Input Errors**: Invalid date format, missing argument
2. **Storage Errors**: Corrupted registry, permission denied
3. **Resource Errors**: Missing files, broken links (expected, non-fatal)
4. **Unexpected Errors**: Catch-all with stack trace in debug mode

#### C. Implementation Guidelines

**Key Logic:**

```javascript
/**
 * Clean Command Handler
 * Implements FR-6, FR-8.4: Remove old transcripts
 *
 * @param {string} dateString - Date boundary in YYYY-MM-DD format
 * @returns {Promise<void>}
 */
async function cleanCommand(dateString) {
  // Guard: Validate date argument provided
  if (!dateString) {
    console.error('Error: Date argument required');
    console.error('Usage: transcriptor clean YYYY-MM-DD');
    console.error('Example: transcriptor clean 2025-11-01');
    process.exit(2); // Exit code 2: Validation failure
  }

  // Wrap entire command in try-catch for unexpected errors
  try {
    // Step 1: Validate date
    // (implementation from Step 1)

    // Step 2: Load and filter
    // (implementation from Step 2)

    // Step 3: Delete transcripts
    // (implementation from Step 3)

    // Step 4: Display summary
    // (implementation from Step 4)

    // Exit with appropriate status
    // Exit code 0: Full success
    // Exit code 1: Partial success with errors
    // Exit code 2: Validation failure (no operations performed)
    if (results.errors.length > 0) {
      process.exit(1);
    }

  } catch (error) {
    // Catch-all for unexpected errors
    console.error('\nUnexpected error during cleanup:', error.message);

    if (process.env.NODE_ENV !== 'production') {
      console.error('Stack trace:', error.stack);
    }

    console.error('\nCleanup may be partially complete.');
    console.error('Review registry state and try again.');

    // Exit code 1 for unexpected errors during execution
    process.exit(1);
  }
}

module.exports = cleanCommand;
```

**Critical Points:**

- Validate date argument presence before operations
- Display usage example on input errors
- Distinguish fatal errors (exit immediately) from non-fatal (continue processing)
- Missing resources (ENOENT) treated as warnings during deletion
- Stack trace shown in non-production environments for debugging
- Exit codes: 0 = success, 1 = errors occurred
- Clear guidance for partial completion scenarios

#### D. Success Criteria

- [ ] Missing date argument caught with usage message
- [ ] Invalid date format caught with clear error (exit code 2)
- [ ] Corrupted registry detected and reported
- [ ] Permission errors caught and explained
- [ ] Missing files handled as warnings (ENOENT non-fatal)
- [ ] Unexpected errors caught with stack trace in debug mode
- [ ] Exit codes correctly indicate: 0=success, 1=errors, 2=validation failure
- [ ] Partial completion state clearly communicated
- [ ] Exit code semantics documented in error handling comments

#### E. Dependencies & Inputs

- Requires: All previous steps, error handling utilities
- Input: Error conditions throughout command execution
- Produces: Clear error messages, appropriate exit codes

---

## Task Breakdown Updates

### New Subtasks Identified

No additional subtasks needed beyond 6.4.1-6.4.4. Implementation can proceed with existing task structure.

---

## Technical Considerations

### Architecture Impact

- **No new components**: Uses existing StorageService, LinkManager, validators utilities
- **Follows established patterns**: Matches process.js and data.js command structure
- **Atomic operations**: Registry saved after each deletion (crash-resilient)
- **Fail-safe design**: Continues on errors, preserves partial progress

### Integration Points

- **StorageService**: Leverages loadRegistry(), saveRegistry(), deleteTranscript()
- **LinkManager**: Uses removeAllLinks() for symbolic link cleanup
- **Validators**: Reuses assertValidDate(), isValidDate() for input validation
- **PathResolver**: Uses getRegistryPath(), getTranscriptsPath() for path resolution

### Risk Mitigation

| Risk | Likelihood | Impact | Mitigation Strategy |
|------|------------|--------|-------------------|
| Registry corruption during deletion | Low | High | Atomic per-entry saves (FR-9.1), atomic write operations (TR-8) |
| Partial deletion on crash | Medium | Medium | Sequential processing, registry saved after each deletion (FR-9.2) |
| Permission errors during cleanup | Medium | Low | Continue on errors, report issues, allow retry (FR-10.1) |
| Invalid date input | High | Low | Early validation with clear error messages, usage examples |
| Large deletion batch performance | Low | Low | Sequential processing ensures stability, progress logging |

### Performance Considerations

- **Expected load**: Small to medium batches (10-100 transcripts typical)
- **Sequential processing**: Ensures stability and crash-resilience over speed
- **Registry writes**: One atomic write per deletion (acceptable for batch size)
- **Optimization opportunities**: None needed for expected scale
- **Monitoring points**: Success count, error count, links removed

---

## Testing Strategy

### Manual Testing

Manual verification during development covers all scenarios:

**Test Scenarios:**
1. Valid date with matching transcripts → successful deletion
2. Valid date with no matching transcripts → graceful no-op
3. Future date → warning but no deletion
4. Invalid date format → clear error message (exit code 2)
5. Missing date argument → usage message (exit code 2)
6. Empty registry → graceful no-op
7. Exclusive boundary verification → keep boundary date, delete older
8. Partial errors → continue processing, report errors (exit code 1)
9. Missing transcript files → warning, continue
10. Link deletion errors → report, continue
11. Malformed registry entry (missing date_added) → skip with warning
12. Empty string date_added → skip with warning
13. Invalid date format in registry → skip with descriptive error
14. Mixed valid and corrupted entries → process valid, skip corrupted with summary
15. Progress reporting → verify [n/total] indicators displayed
16. Concurrent deletion (file already gone) → handle gracefully as warning

### Edge Cases

**Date Parsing:**
- Invalid formats: "11/19/2025", "2025-11-19T00:00:00Z", "2025-11-32"
- Boundary dates: Same as newest transcript, same as oldest transcript
- Future dates: Later than today

**Registry States:**
- Empty registry (new installation)
- Single transcript matching boundary
- All transcripts older than boundary
- No transcripts older than boundary
- Corrupted registry structure (invalid JSON)
- Registry entries missing date_added field
- Registry entries with empty string date_added
- Registry entries with invalid date formats (e.g., "11/19/2025", "2025-13-01")
- Registry entries with null/undefined values
- Mixed valid and corrupted entries

**File System States:**
- Missing transcript files (ENOENT)
- Permission denied (EACCES, EPERM)
- Broken symbolic links (already handled by LinkManager)
- Multiple links per transcript

**Error Conditions:**
- Registry save failure (disk full, permission denied)
- Link deletion permission errors
- File deletion errors
- Unexpected errors during processing

---

## Implementation Notes

### Code Organization

```
src/
├── commands/
│   └── clean.js              # Replace existing stub implementation
├── services/
│   ├── StorageService.js     # Existing - use deleteTranscript(), loadRegistry(), saveRegistry()
│   └── LinkManager.js        # Existing - use removeAllLinks()
└── utils/
    ├── validators.js         # Existing - use assertValidDate(), isValidDate()
    └── pathResolver.js       # Existing - dependency injection
```

### Coding Standards

- **Follow existing patterns**: Match structure of data.js and process.js commands
- **Use existing utilities**: Leverage validators, StorageService, LinkManager (DRY principle)
- **Error handling**: Consistent with process.js (try-catch, guards, clear messages)
- **Console output**: Aligned with data.js format (=== headers, aligned columns)
- **Comments**: JSDoc for function, inline for complex logic
- **Security**: Validate inputs, use validators.assertValidDate()

### Documentation Requirements

- **Inline comments**: Explain date comparison logic (exclusive boundary)
- **JSDoc**: Document function signature, parameters, return value
- **Error messages**: Provide actionable guidance for users
- **No README updates needed**: Command already documented in FR-8.4

---

## Estimated Effort

| Component | Effort | Complexity |
|-----------|--------|------------|
| Date validation and parsing | 0.5 hours | Low |
| Registry loading and filtering | 1 hour | Low |
| Deletion loop implementation | 2 hours | Medium |
| Error handling and edge cases | 1 hour | Medium |
| Testing and validation | 1 hour | Low |
| **Total** | **5.5 hours** | **Overall: Medium** |

Complexity driven by comprehensive error handling and atomic per-entry processing requirements.

---

## Implementation Enhancements Summary

### Bug Prevention Measures

**Registry Data Validation:**
- Helper function `validateRegistryEntry()` ensures all registry entries meet schema requirements before processing
- Prevents crashes from null/undefined entries, missing fields, or invalid date formats
- Corrupted entries tracked and reported separately (not silently ignored)

**Date Boundary Validation:**
- Exclusive boundary semantics enforced (`<` not `<=`) per FR-6.1
- Future date detection prevents accidental full-dataset deletion
- String-based date comparison documented and validated

**Concurrent Operation Safety:**
- ENOENT during file deletion treated as success (idempotent)
- Multiple processes can safely delete same transcripts without conflicts
- Registry atomic writes prevent corruption during concurrent access

### Code Quality Enhancements

**Separation of Concerns:**
- Validation logic extracted to `validateRegistryEntry()` helper function
- Progress reporting logic isolated from deletion logic
- Error handling separated by category (input, storage, resource, unexpected)

**User Experience Improvements:**
- Real-time progress indicators `[n/total]` during deletion loop
- Corrupted entry warnings guide user to run data command for inspection
- Clear exit codes (0/1/2) enable script automation and error detection

**Maintainability:**
- Consistent error message formatting across all commands
- Inline documentation explains complex logic (exclusive boundary, atomic operations)
- Success criteria expanded to cover all edge cases identified during review

### Security Hardening

**Input Validation:**
- Date format validated before any operations using existing `validators.assertValidDate()`
- Video ID validation occurs in LinkManager (defensive programming)
- Absolute path validation prevents path traversal in link operations

**Exit Code Semantics:**
- Exit code 2 for validation failures (no operations performed, safe to retry)
- Exit code 1 for execution errors (partial completion, review state)
- Exit code 0 for complete success
- Enables safe integration with automation scripts

### Testing Coverage

**Enhanced Test Scenarios:**
- Registry corruption scenarios (missing date_added, invalid formats, empty strings)
- Mixed valid/corrupted entry processing
- Concurrent deletion handling
- Progress reporting verification
- Exit code validation for all failure modes

---

## Next Steps

1. Replace existing clean.js stub with full implementation
2. Follow Steps 1-5 sequentially as documented
3. Test with various date inputs and registry states
4. Verify output format matches data.js and process.js style
5. Update tasks.md to check off 6.4.1-6.4.4 upon completion

---

## Revision Notes

### Major Changes from Original

1. **Enhanced Error Handling**: Added comprehensive validation for edge cases including malformed registry entries without date_added field
2. **Security Improvements**: Added input validation against future dates and boundary validation for exclusive deletion semantics
3. **Progress Reporting**: Added real-time progress indication during deletion loop for better user experience
4. **Dry-Run Capability**: Added optional --dry-run flag for safer operation preview before actual deletion
5. **Registry Consistency**: Enhanced registry validation during filtering to prevent processing corrupted entries
6. **Exit Code Standards**: Defined clear exit code semantics (0=success, 1=errors, 2=validation failure)

### Security Enhancements

- Input validation prevents processing invalid date formats that could cause unexpected behavior
- Date boundary validation prevents accidental deletion of all transcripts with future dates
- Registry entry structure validation during filtering prevents processing corrupted data
- Absolute path validation ensures link deletion operations cannot escape expected directories

### Testing Improvements

- Added explicit test scenario for malformed registry entries (missing date_added)
- Added test scenario for empty string date_added values
- Added test scenario for registry entries with invalid date formats
- Added test scenario for concurrent deletion attempts (file already deleted by another process)

### Code Quality Improvements

- Extracted helper function for registry entry validation (DRY principle)
- Separated concerns: date parsing, filtering, deletion, and reporting in distinct functions
- Added inline comments explaining exclusive boundary semantics
- Consistent error message formatting with existing commands (data.js, process.js)
- Progress indication using ConsoleFormatter utility for consistent output style

---

## References

- **Functional Requirements**: FR-6 (Cleanup Operations), FR-6.1 (Clean command spec), FR-6.2 (Per-entry processing), FR-8.4 (Command interface), FR-9.1 (Atomic writes), FR-10 (Failure recovery), FR-10.1 (Continue after failures), FR-10.2 (Handle missing resources)
- **Technical Requirements**: TR-4 (Clean command specification), TR-8 (Atomic write pattern), TR-13 (File system errors), TR-16 (Registry persistence)
- **Business Rules**: BR-3 (Link management), BR-4 (Date handling YYYY-MM-DD format)
- **Related Tasks**: 3.2 (Registry operations), 5.3 (Link management), 6.3 (Data command for consistent output format)
- **Existing Code**: StorageService.js (deleteTranscript, loadRegistry, saveRegistry), LinkManager.js (removeAllLinks), validators.js (assertValidDate, isValidDate), data.js (output format reference), process.js (error handling patterns)
