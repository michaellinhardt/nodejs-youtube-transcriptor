# Remediation Plan: Architectural Fidelity

**Date:** 2025-11-19
**Task Reference:** 3.2 Registry Operations (from @dev/tasks.md)
**Status:** Ready for Implementation

## Summary of Plan

This remediation plan addresses critical architectural violations and design pattern deviations identified in the StorageService implementation, specifically within the registry operations methods added for task 3.2. The implementation introduces several helper methods (`addTranscript`, `removeTranscript`, `removeLink`, `hasTranscript`, `validateIntegrity`, `getAllTranscripts`, `getTranscriptsBeforeDate`) that violate the established architectural boundaries and exceed the documented scope of FR-3.2 and TR-16.

The primary issues are:

1. **Architectural Boundary Violation**: Registry operations (StorageService) contain orchestration logic that belongs in TranscriptService
2. **Scope Creep**: Implementation includes features (integrity validation, transcript filtering) not specified in FR-3.2/TR-16
3. **Tight Coupling**: Direct require() calls to validators within methods create coupling that violates dependency injection patterns
4. **Responsibility Confusion**: Storage layer performing business logic operations instead of pure data persistence

Fixing these violations is critical because they blur service boundaries, making the codebase harder to test, maintain, and evolve. The remediation will realign the implementation with the documented architecture where StorageService handles only data persistence (registry read/write/update), while TranscriptService orchestrates business logic flows.

## Tasks Planned

This plan targets the implementation of:

- 3.2 Registry operations (implements FR-3.2, TR-16)
  - 3.2.1 Implement registry loading from data.json
  - 3.2.2 Create registry update methods
  - 3.2.3 Implement atomic write operations (TR-8)
  - 3.2.4 Add registry validation logic

## Plan Overview

The remediation strategy focuses on extracting orchestration logic from StorageService into appropriate service layers while preserving the core registry CRUD operations. The approach involves: (1) retaining only fundamental registry operations (loadRegistry, saveRegistry, basic validation) in StorageService, (2) removing helper methods that orchestrate multiple operations or implement business rules, and (3) ensuring TranscriptService (when implemented in tasks 4.0-5.0) will handle the orchestration previously embedded in these helpers. This maintains clear separation of concerns where StorageService is a pure data access layer, not a business logic coordinator.

## High-Level Steps

1. Identify Core vs Orchestration Methods
2. Remove Orchestration Methods from StorageService
3. Fix Dependency Injection Pattern
4. Validate Registry Schema Alignment
5. Update Task Tracking

## Detailed Breakdown

### Step 1: Identify Core vs Orchestration Methods

#### A. Rationale & Objective

The StorageService has accumulated methods that mix data access concerns with business logic orchestration. This violates the Service Layer pattern where storage services should only handle persistence operations. We must identify which methods belong in StorageService (core data operations) versus TranscriptService (orchestration logic) to restore proper architectural boundaries.

#### B. Recommended Approach & Strategy

**Core Registry Methods (KEEP in StorageService):**

- `loadRegistry()` - Pure data read operation (FR-3.2)
- `saveRegistry()` - Pure data write operation with atomic pattern (TR-8, TR-16)
- `isValidRegistryStructure()` - Data validation (aligns with TR-16)

**Orchestration Methods (REMOVE from StorageService):**

- `addTranscript()` - Orchestrates registry load, modification, and save
- `removeTranscript()` - Orchestrates registry load, modification, and save
- `removeLink()` - Orchestrates registry load, modification, and save
- `hasTranscript()` - Convenience method that combines load + query
- `validateIntegrity()` - Complex business logic involving file system checks (belongs in maintenance service)
- `getAllTranscripts()` - Data transformation/projection (can be in service layer)
- `getTranscriptsBeforeDate()` - Business logic filtering (belongs in cleanup service)

The orchestration methods violate FR-3.2 and TR-16 which specify only "registry loading," "registry update methods," and "atomic write operations." These requirements describe low-level primitives, not high-level workflows.

#### C. Implementation Guidelines

Review each method in StorageService:

- If method performs ONLY file I/O or data structure validation → KEEP
- If method orchestrates multiple operations (load → modify → save) → REMOVE
- If method implements business rules (date filtering, integrity checks) → REMOVE

Document which methods are removed and note that their functionality will be reimplemented in appropriate service layers during tasks 4.0-5.0.

### Step 2: Remove Orchestration Methods from StorageService

#### A. Rationale & Objective

The orchestration methods (`addTranscript`, `removeTranscript`, `removeLink`, `hasTranscript`, `validateIntegrity`, `getAllTranscripts`, `getTranscriptsBeforeDate`) violate the Repository pattern where storage services provide only CRUD operations. These methods will be removed to restore architectural purity, with their functionality to be reimplemented in TranscriptService during tasks 5.1-5.4.

#### B. Recommended Approach & Strategy

Remove the following methods from StorageService entirely:

1. `addTranscript(videoId, linkPath)` - Lines 216-251
2. `removeTranscript(videoId)` - Lines 253-272
3. `removeLink(videoId, linkPath)` - Lines 274-309
4. `hasTranscript(videoId)` - Lines 311-323
5. `validateIntegrity()` - Lines 325-380
6. `getAllTranscripts()` - Lines 382-395
7. `getTranscriptsBeforeDate(beforeDate)` - Lines 397-414

These operations will be reimplemented appropriately:

- Add/remove operations → TranscriptService (task 5.4)
- Integrity validation → Maintenance layer (task 7.1)
- Query operations → TranscriptService or dedicated query service

Retain only these methods in StorageService:

- `constructor(pathResolver)`
- `initialize()`
- `loadRegistry()`
- `isValidRegistryStructure(data)`
- `saveRegistry(data)`
- `saveTranscript(videoId, content)` - stub (task 3.3.1)
- `createSymlink(source, target)` - stub (task 5.3.1)
- `deleteTranscript(videoId)` - stub (task 3.3.4)

#### C. Implementation Guidelines

```javascript
// REMOVE these methods entirely:
async addTranscript(videoId, linkPath) { /* DELETE */ }
async removeTranscript(videoId) { /* DELETE */ }
async removeLink(videoId, linkPath) { /* DELETE */ }
async hasTranscript(videoId) { /* DELETE */ }
async validateIntegrity() { /* DELETE */ }
async getAllTranscripts() { /* DELETE */ }
async getTranscriptsBeforeDate(beforeDate) { /* DELETE */ }
```

The resulting StorageService should contain ONLY:

1. Path and initialization management
2. Registry load/save with validation
3. Stubs for file operations (to be implemented in task 3.3)

This aligns perfectly with FR-3.2 which specifies only: "Implement registry loading," "Create registry update methods" (meaning save/persist), and "Implement atomic write operations."

### Step 3: Fix Dependency Injection Pattern

#### A. Rationale & Objective

The `isValidRegistryStructure()` method uses inline `require()` calls for validators and path modules, violating dependency injection principles and creating hidden coupling. This makes the code harder to test and understand. Dependencies should be injected through the constructor or imported at module level.

#### B. Recommended Approach & Strategy

Move module imports to the top of the file to make dependencies explicit and improve testability. The validators and path utilities are infrastructure dependencies that should be declared at module scope, not dynamically required within methods.

Convert this pattern:

```javascript
isValidRegistryStructure(data) {
  const validators = require('../utils/validators'); // BAD: inline require
  const path = require('path');
  // ...
}
```

To this pattern:

```javascript
// At top of file
const validators = require('../utils/validators');
const path = require('path');

isValidRegistryStructure(data) {
  // Use validators directly
  if (!validators.isValidVideoId(videoId)) return false;
  // ...
}
```

#### C. Implementation Guidelines

```javascript
// Top of StorageService.js - after line 1
const fs = require('fs-extra');
const path = require('path');
const validators = require('../utils/validators');

class StorageService {
  // ... existing code ...

  isValidRegistryStructure(data) {
    if (typeof data !== 'object' || data === null) return false;
    if (Array.isArray(data)) return false;

    // Use imported validators, not require()
    for (const [videoId, entry] of Object.entries(data)) {
      if (!validators.isValidVideoId(videoId)) return false;

      if (!entry || typeof entry !== 'object') return false;
      if (Array.isArray(entry)) return false;
      if (!entry.date_added || typeof entry.date_added !== 'string') return false;
      if (!Array.isArray(entry.links)) return false;

      if (!validators.isValidDate(entry.date_added)) return false;

      // Use imported path, not require()
      if (
        !entry.links.every((link) => {
          if (typeof link !== 'string' || link.trim() === '') return false;
          return path.isAbsolute(link);
        })
      )
        return false;

      const allowedKeys = ['date_added', 'links'];
      const entryKeys = Object.keys(entry);
      if (entryKeys.some((key) => !allowedKeys.includes(key))) return false;
    }

    return true;
  }
}
```

Remove inline require() calls and reference module-level imports instead.

### Step 4: Validate Registry Schema Alignment

#### A. Rationale & Objective

Verify that the `isValidRegistryStructure()` implementation correctly enforces the registry schema defined in TR-10 and FR-3.2. The validation logic must match the documented data model precisely to ensure data integrity.

#### B. Recommended Approach & Strategy

Compare current validation implementation against documented schema in @docs/requirements_technical.md (TR-10, Data Models section):

```yaml
DataRegistry:
  videoId:
    date_added: string|YYYY-MM-DD
    links: array<string>|absolute_paths
```

Current implementation correctly validates:

- ✅ Registry is object (not array, not null)
- ✅ Video IDs match pattern (via validators.isValidVideoId)
- ✅ Entries are objects with date_added (string) and links (array)
- ✅ date_added format is YYYY-MM-DD (via validators.isValidDate)
- ✅ links are absolute paths (via path.isAbsolute)
- ✅ No extra keys beyond ['date_added', 'links']

The implementation appears compliant with the schema. Validation should remain as-is after removing inline require() calls.

#### C. Implementation Guidelines

No changes needed to validation logic itself. After applying Step 3 (dependency injection fix), verify validation behavior:

```javascript
// Validation should enforce this structure:
{
  "[video-id]": {
    "date_added": "YYYY-MM-DD",
    "links": ["/absolute/path1", "/absolute/path2"]
  }
}

// Should reject:
// - Non-objects or arrays at root
// - Invalid video IDs as keys
// - Missing date_added or links
// - Non-YYYY-MM-DD dates
// - Relative paths in links array
// - Extra properties beyond date_added/links
```

Test validation with edge cases after remediation to ensure schema enforcement remains intact.

### Step 5: Update Task Tracking

#### A. Rationale & Objective

Task 3.2 in @dev/tasks.md is marked complete but the implementation exceeds the specified scope. After removing orchestration methods, the task will accurately reflect completion of only FR-3.2 and TR-16 requirements (registry load, save, atomic write, basic validation).

#### B. Recommended Approach & Strategy

The task list already shows task 3.2 as complete:

```markdown
- [x] 3.2 Registry operations (implements FR-3.2, TR-16)
  - [x] 3.2.1 Implement registry loading from data.json
  - [x] 3.2.2 Create registry update methods
  - [x] 3.2.3 Implement atomic write operations (TR-8)
  - [x] 3.2.4 Add registry validation logic
```

After remediation, verify that the checked subtasks accurately reflect what remains in StorageService:

- 3.2.1: `loadRegistry()` ✓
- 3.2.2: `saveRegistry()` ✓ (this is the registry "update method" - persist changes)
- 3.2.3: Atomic write pattern in `saveRegistry()` with .tmp file ✓
- 3.2.4: `isValidRegistryStructure()` ✓

The removed methods (`addTranscript`, etc.) were never in scope for 3.2 and should not affect task completion status. They will be implemented properly in tasks 5.4 and 7.1 where they architecturally belong.

#### C. Implementation Guidelines

No changes to @dev/tasks.md are required. Task 3.2 should remain marked complete as the core registry operations (load, save, validate, atomic write) are correctly implemented.

Document in code comments that higher-level operations (add/remove transcripts, integrity checks) are deferred to appropriate service layers per tasks 5.4 and 7.1.

## Validation Checklist

- [ ] StorageService contains ONLY loadRegistry, saveRegistry, isValidRegistryStructure, and file operation stubs
- [ ] All orchestration methods (addTranscript, removeTranscript, etc.) removed from StorageService
- [ ] Dependencies (validators, path) imported at module level, not inline require()
- [ ] Registry validation matches documented schema (FR-3.2, TR-10)
- [ ] Task 3.2 completion status verified as accurate
- [ ] Code comments document that orchestration logic belongs in TranscriptService (tasks 5.4, 7.1)
