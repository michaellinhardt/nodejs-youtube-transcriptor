# Refactoring Plan: Clean Code Improvements

**Date:** 2025-11-19
**Task Reference:** 3.3 (File operations - implements TR-17)
**Code Smells Addressed:** CLEAN-01, CLEAN-02, CLEAN-03, CLEAN-04, CLEAN-05, CLEAN-06
**Status:** Ready for Implementation

## Plan Overview

This plan addresses clean code issues in the StorageService.js file, specifically in the four newly implemented file operation methods: saveTranscript, readTranscript, transcriptExists, and deleteTranscript. These methods handle core file I/O operations for transcript storage and retrieval. While the implementations are functionally sound with good error handling, they suffer from extensive code duplication, inconsistent error message patterns, and excessive complexity due to repeated initialization/validation patterns. The refactoring will extract common patterns into reusable helper methods, establish consistent error messaging, reduce nesting through guard clauses, and improve overall readability while maintaining the robust error handling that is already in place.

## Tasks Planned

- 3.3 File operations (implements TR-17)
  - 3.3.1 Implement transcript save functionality
  - 3.3.2 Create transcript read methods
  - 3.3.3 Add file existence checking
  - 3.3.4 Implement file deletion with error handling

## Refactoring Goals

- Eliminate 4 instances of duplicated initialization/validation pattern
- Reduce average method complexity by extracting common guard patterns
- Establish consistent error message format across all file operations
- Reduce conditional nesting depth from 3-4 levels to max 2 levels
- Extract reusable file system error handling patterns
- Improve code maintainability through Single Responsibility Principle

## High-Level Steps

1. Extract common initialization/validation pattern
2. Create reusable path building helper
3. Establish consistent error message factory
4. Extract file system error handling logic
5. Apply guard clauses to reduce nesting
6. Introduce named constants for validation limits

## Detailed Breakdown

### Step 1: Extract Initialization/Validation Pattern

#### A. Rationale & Objective

All four methods (saveTranscript, readTranscript, transcriptExists, deleteTranscript) share identical initialization and validation logic:

```javascript
// Repeated 4 times
try {
  await this.initialize();
} catch (initError) {
  throw new Error(`Cannot [operation] (initialization failed): ${initError.message}`);
}

if (!validators.isValidVideoId(videoId)) {
  throw new Error(`Invalid video ID format: ${videoId}`);
}
```

This violates DRY principle and creates maintenance burden - any change to initialization logic requires updates in 4 locations. Extracting this pattern will centralize validation logic and reduce code by approximately 32 lines.

#### B. Refactoring Strategy

Create a private helper method `_ensureInitializedWithValidId` that encapsulates both initialization and video ID validation, throwing contextual errors.

#### C. Implementation

**Before: Duplicated in 4 methods**

```javascript
async saveTranscript(videoId, content) {
  // Initialize storage before operations
  try {
    await this.initialize();
  } catch (initError) {
    throw new Error(`Cannot save transcript (initialization failed): ${initError.message}`);
  }

  // Validate inputs
  if (!validators.isValidVideoId(videoId)) {
    throw new Error(`Invalid video ID format: ${videoId}`);
  }
  // ... rest of method
}

async readTranscript(videoId) {
  // Initialize storage before operations
  try {
    await this.initialize();
  } catch (initError) {
    throw new Error(`Cannot read transcript (initialization failed): ${initError.message}`);
  }

  // Validate input
  if (!validators.isValidVideoId(videoId)) {
    throw new Error(`Invalid video ID format: ${videoId}`);
  }
  // ... rest of method
}

// ... same pattern in transcriptExists and deleteTranscript
```

**After: Extracted helper method**

```javascript
/**
 * Ensure storage initialized and video ID valid
 * @private
 * @param {string} videoId - Video ID to validate
 * @param {string} operation - Operation name for error context
 * @returns {Promise<void>}
 * @throws {Error} If initialization fails or video ID invalid
 */
async _ensureInitializedWithValidId(videoId, operation) {
  try {
    await this.initialize();
  } catch (initError) {
    throw new Error(`Cannot ${operation} (initialization failed): ${initError.message}`);
  }

  if (!validators.isValidVideoId(videoId)) {
    throw new Error(`Invalid video ID format: ${videoId}`);
  }
}

// Usage in methods
async saveTranscript(videoId, content) {
  await this._ensureInitializedWithValidId(videoId, 'save transcript');
  // ... rest of method
}

async readTranscript(videoId) {
  await this._ensureInitializedWithValidId(videoId, 'read transcript');
  // ... rest of method
}

async transcriptExists(videoId) {
  await this._ensureInitializedWithValidId(videoId, 'check transcript existence');
  // ... rest of method
}

async deleteTranscript(videoId) {
  await this._ensureInitializedWithValidId(videoId, 'delete transcript');
  // ... rest of method
}
```

### Step 2: Extract Path Building Logic

#### A. Rationale & Objective

All four methods build the transcript file path identically:

```javascript
const transcriptPath = path.join(
  this.paths.getTranscriptsPath(),
  `${videoId}.md`
);
```

This 3-line pattern is repeated 4 times. Extracting to a helper method centralizes path construction logic and provides a single point of change if path structure evolves.

#### B. Implementation

**Before: Duplicated in 4 methods**

```javascript
async saveTranscript(videoId, content) {
  // ... validation
  const transcriptPath = path.join(
    this.paths.getTranscriptsPath(),
    `${videoId}.md`
  );
  // ... use transcriptPath
}
```

**After: Extracted helper**

```javascript
/**
 * Build transcript file path for video ID
 * @private
 * @param {string} videoId - YouTube video ID
 * @returns {string} Absolute path to transcript file
 */
_getTranscriptPath(videoId) {
  return path.join(
    this.paths.getTranscriptsPath(),
    `${videoId}.md`
  );
}

// Usage
async saveTranscript(videoId, content) {
  // ... validation
  const transcriptPath = this._getTranscriptPath(videoId);
  // ... use transcriptPath
}
```

### Step 3: Extract File System Error Handling Patterns

#### A. Rationale & Objective

Methods handle fs errors with similar patterns but inconsistent implementation:

- readTranscript: Handles ENOENT, EACCES/EPERM, and re-throws others
- transcriptExists: Handles ENOENT, EACCES/EPERM with console.warn fallback
- deleteTranscript: Handles ENOENT, EISDIR/EPERM, EACCES with different messages
- saveTranscript: Handles EEXIST in ensureDir, generic writeFile errors

This duplication creates inconsistency. Error handling for common fs codes should be centralized.

#### B. Refactoring Strategy

Create helper methods for common error handling patterns:
- `_handleReadError(error, videoId)` - For read/stat operations
- `_handleWriteError(error, videoId)` - For write operations
- `_handleDeleteError(error, videoId)` - For delete operations

#### C. Implementation

**Before: Scattered error handling**

```javascript
// In readTranscript
catch (error) {
  if (error.code === 'ENOENT') {
    throw new Error(`Transcript not found: ${videoId}`);
  }
  if (error.code === 'EACCES' || error.code === 'EPERM') {
    throw new Error(`Permission denied reading transcript ${videoId}: ${error.message}`);
  }
  throw error;
}

// In transcriptExists
catch (error) {
  if (error.code === 'ENOENT') {
    return false;
  }
  if (error.code === 'EACCES' || error.code === 'EPERM') {
    console.warn(`Permission denied checking transcript ${videoId}`);
    return false;
  }
  console.warn(`transcriptExists check failed for ${videoId}: ${error.message}`);
  return false;
}

// In deleteTranscript
catch (error) {
  if (error.code === 'ENOENT') {
    return;
  }
  if (error.code === 'EISDIR' || error.code === 'EPERM') {
    throw new Error(`Cannot delete: path is not a file (${videoId})`);
  }
  if (error.code === 'EACCES') {
    throw new Error(`Permission denied deleting transcript ${videoId}: ${error.message}`);
  }
  throw new Error(`Failed to delete transcript ${videoId}: ${error.message}`);
}
```

**After: Centralized error handlers**

```javascript
/**
 * Handle read operation errors with consistent patterns
 * @private
 * @param {Error} error - File system error
 * @param {string} videoId - Video ID for context
 * @param {string} operation - Operation description
 * @throws {Error} Contextualized error
 */
_handleReadError(error, videoId, operation) {
  if (error.code === 'ENOENT') {
    throw new Error(`Transcript not found: ${videoId}`);
  }

  if (error.code === 'EACCES' || error.code === 'EPERM') {
    throw new Error(`Permission denied ${operation} transcript ${videoId}`);
  }

  // Re-throw with original context for unexpected errors
  throw error;
}

/**
 * Handle existence check errors (returns false instead of throwing)
 * @private
 * @param {Error} error - File system error
 * @param {string} videoId - Video ID for context
 * @returns {boolean} Always false (non-existent or inaccessible)
 */
_handleExistenceCheckError(error, videoId) {
  if (error.code === 'ENOENT') {
    return false;
  }

  if (error.code === 'EACCES' || error.code === 'EPERM') {
    console.warn(`Permission denied checking transcript ${videoId}`);
    return false;
  }

  console.warn(`Existence check failed for ${videoId}: ${error.message}`);
  return false;
}

/**
 * Handle delete operation errors
 * @private
 * @param {Error} error - File system error
 * @param {string} videoId - Video ID for context
 * @throws {Error} Contextualized error (or returns for ENOENT)
 */
_handleDeleteError(error, videoId) {
  // Idempotent - already deleted is success
  if (error.code === 'ENOENT') {
    return;
  }

  if (error.code === 'EISDIR' || error.code === 'EPERM') {
    throw new Error(`Cannot delete: path is not a file (${videoId})`);
  }

  if (error.code === 'EACCES') {
    throw new Error(`Permission denied deleting transcript ${videoId}`);
  }

  throw new Error(`Failed to delete transcript ${videoId}: ${error.message}`);
}

// Usage
async readTranscript(videoId) {
  // ... validation and path building
  try {
    const content = await fs.readFile(transcriptPath, { encoding: 'utf8' });
    if (content.length === 0) {
      throw new Error(`Transcript file is empty for video ID: ${videoId}`);
    }
    return content;
  } catch (error) {
    this._handleReadError(error, videoId, 'reading');
  }
}

async transcriptExists(videoId) {
  // ... validation and path building
  try {
    const stats = await fs.stat(transcriptPath);
    return stats.isFile() && stats.size > 0;
  } catch (error) {
    return this._handleExistenceCheckError(error, videoId);
  }
}

async deleteTranscript(videoId) {
  // ... validation and path building
  try {
    await fs.unlink(transcriptPath);
  } catch (error) {
    this._handleDeleteError(error, videoId);
  }
}
```

### Step 4: Introduce Named Constants

#### A. Rationale & Objective

Magic numbers appear in saveTranscript:

```javascript
const maxSizeBytes = 10 * 1024 * 1024; // 10MB
```

This value is documented in TR specs but embedded as magic number. Should be a named constant at class level for clarity and maintainability.

#### B. Implementation

**Before: Magic number**

```javascript
async saveTranscript(videoId, content) {
  // ... validation
  const maxSizeBytes = 10 * 1024 * 1024; // 10MB
  const contentSizeBytes = Buffer.byteLength(content, 'utf8');
  if (contentSizeBytes > maxSizeBytes) {
    throw new Error(`Transcript exceeds size limit (${contentSizeBytes} bytes > ${maxSizeBytes} bytes) for video ID: ${videoId}`);
  }
  // ...
}
```

**After: Named constant**

```javascript
class StorageService {
  // Class-level constants (add near top of class)
  static MAX_TRANSCRIPT_SIZE_BYTES = 10 * 1024 * 1024; // 10MB (TR specs)

  async saveTranscript(videoId, content) {
    // ... validation
    const contentSizeBytes = Buffer.byteLength(content, 'utf8');
    if (contentSizeBytes > StorageService.MAX_TRANSCRIPT_SIZE_BYTES) {
      throw new Error(
        `Transcript exceeds size limit (${contentSizeBytes} bytes > ${StorageService.MAX_TRANSCRIPT_SIZE_BYTES} bytes) for video ID: ${videoId}`
      );
    }
    // ...
  }
}
```

### Step 5: Simplify saveTranscript Content Validation

#### A. Rationale & Objective

Content validation in saveTranscript has redundant checks:

```javascript
if (typeof content !== 'string') {
  throw new Error(`Invalid content type: expected string, got ${typeof content}`);
}

if (content.length === 0) {
  throw new Error(`Cannot save empty transcript for video ID: ${videoId}`);
}
```

The type check and length check can be combined into more focused validation. Additionally, the comment "SECURITY: Additional validation beyond regex" is misleading - empty string validation is business logic, not security.

#### B. Implementation

**Before: Verbose validation**

```javascript
// Validate inputs
if (!validators.isValidVideoId(videoId)) {
  throw new Error(`Invalid video ID format: ${videoId}`);
}

if (typeof content !== 'string') {
  throw new Error(`Invalid content type: expected string, got ${typeof content}`);
}

// SECURITY: Additional validation beyond regex
if (content.length === 0) {
  throw new Error(`Cannot save empty transcript for video ID: ${videoId}`);
}

// SECURITY: Check content size limit (10MB per TR specs)
```

**After: Focused validation with guard clauses**

```javascript
async saveTranscript(videoId, content) {
  await this._ensureInitializedWithValidId(videoId, 'save transcript');

  // Guard: Validate content type and non-empty
  if (typeof content !== 'string' || content.length === 0) {
    throw new Error(`Invalid content: must be non-empty string (video ID: ${videoId})`);
  }

  // Guard: Check size limit (10MB per TR specs)
  const contentSizeBytes = Buffer.byteLength(content, 'utf8');
  if (contentSizeBytes > StorageService.MAX_TRANSCRIPT_SIZE_BYTES) {
    throw new Error(
      `Transcript exceeds ${StorageService.MAX_TRANSCRIPT_SIZE_BYTES} byte limit (${contentSizeBytes} bytes): ${videoId}`
    );
  }

  // ... rest of method
}
```

### Step 6: Simplify transcriptExists Logic

#### A. Rationale & Objective

transcriptExists has nested conditions that can be flattened:

```javascript
try {
  const stats = await fs.stat(transcriptPath);

  if (!stats.isFile()) {
    return false;
  }

  if (stats.size === 0) {
    return false;
  }

  return true;
} catch (error) {
  // ... error handling
}
```

This can be simplified with direct boolean return.

#### B. Implementation

**Before: Multiple early returns**

```javascript
try {
  const stats = await fs.stat(transcriptPath);

  if (!stats.isFile()) {
    return false;
  }

  if (stats.size === 0) {
    return false;
  }

  return true;
} catch (error) {
  return this._handleExistenceCheckError(error, videoId);
}
```

**After: Direct boolean expression**

```javascript
try {
  const stats = await fs.stat(transcriptPath);
  return stats.isFile() && stats.size > 0;
} catch (error) {
  return this._handleExistenceCheckError(error, videoId);
}
```

### Step 7: Improve readTranscript Empty File Handling

#### A. Rationale & Objective

readTranscript checks for empty content after reading:

```javascript
const content = await fs.readFile(transcriptPath, { encoding: 'utf8' });

// ENHANCEMENT: Validate non-empty content
if (content.length === 0) {
  throw new Error(`Transcript file is empty for video ID: ${videoId}`);
}

return content;
```

This reads the entire file before checking size. For consistency with transcriptExists (which uses stat), we should use guard clause pattern. However, since empty file check is already present, we can simplify the comment and improve error message consistency.

#### B. Implementation

**Before: Comment suggests enhancement**

```javascript
try {
  const content = await fs.readFile(transcriptPath, { encoding: 'utf8' });

  // ENHANCEMENT: Validate non-empty content
  if (content.length === 0) {
    throw new Error(`Transcript file is empty for video ID: ${videoId}`);
  }

  return content;
} catch (error) {
  // ... error handling
}
```

**After: Guard clause with consistent error format**

```javascript
try {
  const content = await fs.readFile(transcriptPath, { encoding: 'utf8' });

  // Guard: Reject empty files (corrupted data)
  if (content.length === 0) {
    throw new Error(`Transcript file is empty: ${videoId}`);
  }

  return content;
} catch (error) {
  this._handleReadError(error, videoId, 'reading');
}
```

## Code Quality Patterns Applied

### Single Responsibility Principle

**Before:** Each method handles initialization, validation, path building, operation execution, and error handling.

**After:** Methods delegate to focused helpers:
- `_ensureInitializedWithValidId`: Initialization + validation
- `_getTranscriptPath`: Path building
- `_handleReadError`, `_handleExistenceCheckError`, `_handleDeleteError`: Error handling

### Guard Clauses

**Before:** Nested try-catch with multiple conditional checks.

**After:** Early validation with immediate returns/throws.

```javascript
// Before
if (content) {
  if (content.length > 0) {
    // process
  }
}

// After
if (!content || content.length === 0) {
  throw new Error('Invalid content');
}
// process
```

### DRY Principle

**Eliminated duplication:**
- 4 instances of initialization/validation → 1 helper method
- 4 instances of path building → 1 helper method
- 3 instances of error handling → 3 focused helper methods

## Validation Checklist

- [ ] Extract `_ensureInitializedWithValidId` helper method
- [ ] Extract `_getTranscriptPath` helper method
- [ ] Extract `_handleReadError` helper method
- [ ] Extract `_handleExistenceCheckError` helper method
- [ ] Extract `_handleDeleteError` helper method
- [ ] Add `MAX_TRANSCRIPT_SIZE_BYTES` class constant
- [ ] Simplify saveTranscript content validation
- [ ] Simplify transcriptExists boolean logic
- [ ] Update readTranscript empty file handling
- [ ] Update all four methods to use new helpers
- [ ] Verify error messages are consistent
- [ ] Remove misleading SECURITY/ENHANCEMENT comments
- [ ] Ensure no functionality changes (behavior-preserving refactoring)

## Implementation Impact

**Lines of code reduction:** ~80 lines (from ~240 to ~160)
**Complexity reduction:** Average cyclomatic complexity per method decreases from ~8 to ~4
**Maintainability improvement:** Single point of change for common patterns
**Consistency improvement:** Unified error handling and validation patterns

## Key Constraints

**MUST preserve:**
- All error handling behaviors (ENOENT, EACCES, EPERM, etc.)
- Idempotent delete operation (ENOENT returns silently)
- Empty file rejection in readTranscript and transcriptExists
- Size limit validation in saveTranscript
- UTF-8 encoding for all file operations

**MUST NOT change:**
- Method signatures
- Public API contracts
- Error message meanings (format can improve for consistency)
- Functional behavior of any operation
