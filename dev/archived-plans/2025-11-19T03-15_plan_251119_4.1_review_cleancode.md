# Refactoring Plan: Clean Code Improvements

**Date:** 2025-11-19
**Task Reference:** 4.1 from ./dev/tasks.md
**Code Smells Addressed:** CLEAN-01 through CLEAN-08
**Status:** Ready for Implementation

## Plan Overview

This plan addresses critical code clarity and maintainability issues identified in the APIClient.js implementation. The code has grown to 722 lines with excessive complexity, deeply nested conditionals, long methods, and unclear naming. While functionality appears complete per task 4.1 (API client setup with bug fixes), the code violates multiple clean code principles including Single Responsibility, function length constraints, and complexity limits. This refactoring will improve readability, reduce cognitive load, establish clear method boundaries, and make the codebase more maintainable for future enhancements without altering external behavior.

## Tasks Planned

- 4.1 API client setup [CRITICAL PATH] (implements FR-2.1) [BUG FIXES APPLIED 2025-11-19]
  - 4.1.1 Create APIClient service class
  - 4.1.2 Configure axios with base settings
  - 4.1.3 Add API key header injection
  - 4.1.4 Set timeout configuration (30s)
  - 4.1.5 Fix null/undefined error response handling
  - 4.1.6 Add interceptor response config null safety
  - 4.1.7 Fix initialization state race condition
  - 4.1.8 Add empty string after trim validation
  - 4.1.9 Add error code null/undefined checks
  - 4.1.10 Fix sanitize context non-string data
  - 4.1.11 Add validateVideoUrl edge cases
  - 4.1.12 Fix request interceptor error handler
  - 4.1.13 Add handleNetworkError null safety
  - 4.1.14 Remove fetchTranscript try-catch redundancy
  - 4.1.15 Add response validation null safety
  - 4.1.16 Fix getSanitizedConfig shallow copy issue
  - 4.1.17 Fix transformError default case type safety
  - 4.1.18 Add initialization cleanup on failure

## Refactoring Goals

- Reduce APIClient.js from 722 lines to <500 lines through extraction
- Reduce average method length from current 25+ lines to <20 lines
- Eliminate all methods exceeding 30 lines
- Reduce cyclomatic complexity in fetchWithRetry, transformError, extractVideoIdFromLine
- Establish clear naming for abbreviated/unclear variables (ms, parsed, trimmed)
- Eliminate duplicate validation patterns across multiple methods
- Reduce nesting depth from 4+ levels to max 3 levels
- Extract static configuration into separate constants file

## High-Level Steps

1. Extract static configuration constants into dedicated constants file
2. Decompose long methods (fetchWithRetry, transformError, parseContent)
3. Eliminate duplicate validation logic patterns
4. Apply guard clauses to reduce nesting depth
5. Rename unclear variables for intent clarity
6. Extract error creation/handling into dedicated module
7. Simplify interceptor implementations
8. Consolidate URL/ID validation logic

## Detailed Breakdown

### Step 1: Extract Configuration Constants

#### A. Rationale & Objective

APIClient contains 76 lines of static configuration (lines 35-75) cluttering the class definition. These constants represent configuration, not behavior, and should be externalized per separation of concerns. Extracting to a dedicated constants file improves discoverability, reusability, and testability while reducing the main class to core logic.

#### B. Refactoring Strategy

Create src/constants/APIClientConstants.js containing all static configuration. Update APIClient to import and reference these constants. This establishes a single source of truth for configuration values.

#### C. Extraction Pattern

**Before: Embedded Configuration**

```javascript
class APIClient {
  static API_BASE_URL = 'https://api.scrape-creators.com';
  static API_ENDPOINT = '/transcript';
  static REQUEST_TIMEOUT_MS = 30000;
  static API_KEY_HEADER = 'x-api-key';
  static MAX_API_KEY_LENGTH = 500;

  static ERROR_TYPES = {
    INVALID_REQUEST: 'INVALID_REQUEST',
    // ... 8 error types
  };

  static TIMEOUT_ERROR_CODES = ['ECONNABORTED', 'ETIMEDOUT'];
  static NETWORK_ERROR_CODES = [
    'ECONNREFUSED',
    // ... 7 error codes
  ];

  static RETRY_CONFIG = {
    maxAttempts: 3,
    // ... 6 configuration keys
  };

  static RETRY_BUDGET = {
    maxTotalRetryTimeMs: 60000,
    maxRetryAfterSeconds: 300,
  };
}
```

**After: Dedicated Constants File**

```javascript
// src/constants/APIClientConstants.js
const API_CLIENT_CONFIG = {
  BASE_URL: 'https://api.scrape-creators.com',
  ENDPOINT: '/transcript',
  TIMEOUT_MS: 30000,
  API_KEY_HEADER: 'x-api-key',
  MAX_API_KEY_LENGTH: 500,
};

const ERROR_TYPES = {
  INVALID_REQUEST: 'INVALID_REQUEST',
  UNAUTHORIZED: 'UNAUTHORIZED',
  RATE_LIMITED: 'RATE_LIMITED',
  SERVER_ERROR: 'SERVER_ERROR',
  TIMEOUT: 'TIMEOUT',
  NETWORK: 'NETWORK',
  VALIDATION: 'VALIDATION',
  UNKNOWN_HTTP_ERROR: 'UNKNOWN_HTTP_ERROR',
};

const TIMEOUT_ERROR_CODES = ['ECONNABORTED', 'ETIMEDOUT'];

const NETWORK_ERROR_CODES = [
  'ECONNREFUSED',
  'ECONNRESET',
  'ENOTFOUND',
  'ENETUNREACH',
  'EAI_AGAIN',
  'CERT_HAS_EXPIRED',
  'UNABLE_TO_VERIFY_LEAF_SIGNATURE',
];

const RETRY_CONFIG = {
  MAX_ATTEMPTS: 3,
  INITIAL_DELAY_MS: 1000,
  BACKOFF_MULTIPLIER: 2,
  JITTER_PERCENT: 0.25,
  MAX_DELAY_MS: 8000,
  MIN_DELAY_MS: 100,
};

const RETRY_BUDGET = {
  MAX_TOTAL_RETRY_TIME_MS: 60000,
  MAX_RETRY_AFTER_SECONDS: 300,
};

module.exports = {
  API_CLIENT_CONFIG,
  ERROR_TYPES,
  TIMEOUT_ERROR_CODES,
  NETWORK_ERROR_CODES,
  RETRY_CONFIG,
  RETRY_BUDGET,
};
```

```javascript
// src/services/APIClient.js (updated)
const {
  API_CLIENT_CONFIG,
  ERROR_TYPES,
  TIMEOUT_ERROR_CODES,
  NETWORK_ERROR_CODES,
  RETRY_CONFIG,
  RETRY_BUDGET,
} = require('../constants/APIClientConstants');

class APIClient {
  // Clean class definition without configuration clutter
}
```

### Step 2: Decompose Long Methods

#### A. Method Decomposition Strategy

Three methods violate the <20 line guideline: fetchWithRetry (30 lines), transformError (62 lines), and parseContent (63 lines in URLParser). These methods mix multiple levels of abstraction and responsibilities. Decomposition will extract cohesive sub-operations into focused helper methods.

#### B. Extraction Pattern: fetchWithRetry

**Original Long Method (30 lines):**

```javascript
async fetchWithRetry(videoUrl, attempt = 1, budgetStartTime = null) {
  if (attempt === 1) {
    budgetStartTime = Date.now();
    this.retryBudgetStartTime = budgetStartTime;
  }

  try {
    const response = await this.httpClient.post(
      APIClient.API_ENDPOINT,
      { url: videoUrl }
    );
    return this.extractTranscriptText(response);
  } catch (error) {
    if (this.isRetriableError(error) && attempt < APIClient.RETRY_CONFIG.maxAttempts) {
      this.enforceRetryBudget(budgetStartTime);

      const delay = this.calculateRetryDelay(error, attempt);

      console.warn(
        `[API] Rate limited. Retry ${attempt}/${APIClient.RETRY_CONFIG.maxAttempts - 1} ` +
        `after ${delay}ms (total elapsed: ${Date.now() - budgetStartTime}ms)`
      );

      await this.sleepWithCleanup(delay);

      return this.fetchWithRetry(videoUrl, attempt + 1, budgetStartTime);
    }

    throw error;
  }
}
```

**Refactored into Focused Methods:**

```javascript
async fetchWithRetry(videoUrl, attempt = 1, budgetStartTime = null) {
  const startTime = this.initializeRetryTracking(attempt, budgetStartTime);

  try {
    return await this.executeApiRequest(videoUrl);
  } catch (error) {
    return await this.handleRetryOrThrow(error, videoUrl, attempt, startTime);
  }
}

initializeRetryTracking(attempt, budgetStartTime) {
  if (attempt === 1) {
    const startTime = Date.now();
    this.retryBudgetStartTime = startTime;
    return startTime;
  }
  return budgetStartTime;
}

async executeApiRequest(videoUrl) {
  const response = await this.httpClient.post(
    API_CLIENT_CONFIG.ENDPOINT,
    { url: videoUrl }
  );
  return this.extractTranscriptText(response);
}

async handleRetryOrThrow(error, videoUrl, attempt, startTime) {
  if (!this.shouldRetry(error, attempt)) {
    throw error;
  }

  this.enforceRetryBudget(startTime);
  const delayMs = this.calculateRetryDelay(error, attempt);

  this.logRetryAttempt(attempt, delayMs, startTime);

  await this.sleepWithCleanup(delayMs);

  return this.fetchWithRetry(videoUrl, attempt + 1, startTime);
}

shouldRetry(error, attempt) {
  return this.isRetriableError(error) && attempt < RETRY_CONFIG.MAX_ATTEMPTS;
}

logRetryAttempt(attempt, delayMs, startTime) {
  const elapsedMs = Date.now() - startTime;
  const maxRetries = RETRY_CONFIG.MAX_ATTEMPTS - 1;

  console.warn(
    `[API] Rate limited. Retry ${attempt}/${maxRetries} ` +
    `after ${delayMs}ms (total elapsed: ${elapsedMs}ms)`
  );
}
```

#### C. Extraction Pattern: transformError

**Original Long Method (62 lines):**

```javascript
transformError(error) {
  // Network/timeout errors
  if (!error.response) {
    return this.handleNetworkError(error);
  }

  if (typeof error.response.status !== 'number') {
    console.warn('[API] Malformed error.response - missing status');
    return this.handleNetworkError(error);
  }

  // HTTP errors with response
  const status = error.response.status;
  const errorData = error.response.data || null;

  switch (status) {
    case 400:
      return this.createAppError(
        APIClient.ERROR_TYPES.INVALID_REQUEST,
        'Invalid YouTube URL or video unavailable',
        { status, data: errorData }
      );

    case 401:
      return this.createAppError(
        APIClient.ERROR_TYPES.UNAUTHORIZED,
        'API authentication failed - check SCRAPE_CREATORS_API_KEY',
        { status }
      );

    case 429:
      return this.createAppError(
        APIClient.ERROR_TYPES.RATE_LIMITED,
        'API rate limit exceeded',
        {
          status,
          retryAfter: error.response.headers['retry-after']
        }
      );

    case 500:
    case 502:
    case 503:
      return this.createAppError(
        APIClient.ERROR_TYPES.SERVER_ERROR,
        'API server error - will skip and continue',
        { status, data: errorData }
      );

    default:
      return this.createAppError(
        APIClient.ERROR_TYPES.UNKNOWN_HTTP_ERROR,
        `Unexpected HTTP status: ${status}`,
        { status, data: errorData }
      );
  }
}
```

**Refactored with Extraction:**

```javascript
transformError(error) {
  if (!this.hasValidHttpResponse(error)) {
    return this.handleNetworkError(error);
  }

  const status = error.response.status;
  const errorData = error.response.data || null;
  const headers = error.response.headers || {};

  return this.createHttpError(status, errorData, headers);
}

hasValidHttpResponse(error) {
  return error.response && typeof error.response.status === 'number';
}

createHttpError(status, errorData, headers) {
  const errorMap = {
    400: {
      type: ERROR_TYPES.INVALID_REQUEST,
      message: 'Invalid YouTube URL or video unavailable',
      context: { status, data: errorData }
    },
    401: {
      type: ERROR_TYPES.UNAUTHORIZED,
      message: 'API authentication failed - check SCRAPE_CREATORS_API_KEY',
      context: { status }
    },
    429: {
      type: ERROR_TYPES.RATE_LIMITED,
      message: 'API rate limit exceeded',
      context: {
        status,
        retryAfter: headers['retry-after']
      }
    }
  };

  const serverErrorStatuses = [500, 502, 503];
  if (serverErrorStatuses.includes(status)) {
    return this.createServerError(status, errorData);
  }

  const errorConfig = errorMap[status];
  if (errorConfig) {
    return this.createAppError(errorConfig.type, errorConfig.message, errorConfig.context);
  }

  return this.createUnknownHttpError(status, errorData);
}

createServerError(status, errorData) {
  return this.createAppError(
    ERROR_TYPES.SERVER_ERROR,
    'API server error - will skip and continue',
    { status, data: errorData }
  );
}

createUnknownHttpError(status, errorData) {
  return this.createAppError(
    ERROR_TYPES.UNKNOWN_HTTP_ERROR,
    `Unexpected HTTP status: ${status}`,
    { status, data: errorData }
  );
}
```

### Step 3: Eliminate Duplicate Validation Logic

#### A. DRY Principle Application

Multiple methods repeat null/undefined checks, string validation, and type checking. These patterns appear in validateApiKey, validateVideoUrl, extractVideoIdFromLine, and sanitizeLine. Extract common validation helpers to eliminate duplication.

#### B. Extraction Examples

**Duplicate String Validation:**

```javascript
// Before: Repeated in validateApiKey (lines 130-145)
if (!this.apiKey || typeof this.apiKey !== 'string') {
  throw new Error('API key missing or invalid type');
}

const trimmed = this.apiKey.trim();

if (trimmed === '') {
  throw new Error('API key is empty string');
}

// Before: Repeated in validateVideoUrl (lines 433-437)
if (!url || typeof url !== 'string' || url.trim() === '') {
  throw this.createAppError(
    APIClient.ERROR_TYPES.VALIDATION,
    'Video URL is required and must be non-empty string'
  );
}

// Before: Repeated in sanitizeLine (lines 249-256)
if (!line || typeof line !== 'string') {
  return null;
}

const trimmed = line.trim();

if (trimmed === '' || trimmed.startsWith('#')) {
  return null;
}
```

**After: Extracted Validation Helpers**

```javascript
// src/utils/ValidationHelpers.js
class ValidationHelpers {
  static isNonEmptyString(value) {
    return value && typeof value === 'string' && value.trim() !== '';
  }

  static validateRequiredString(value, fieldName) {
    if (!value || typeof value !== 'string') {
      throw new Error(`${fieldName} missing or invalid type`);
    }

    const trimmedValue = value.trim();

    if (trimmedValue === '') {
      throw new Error(`${fieldName} is empty string`);
    }

    return trimmedValue;
  }

  static sanitizeString(value, maxLength = null) {
    if (!value || typeof value !== 'string') {
      return null;
    }

    const trimmed = value.trim();

    if (trimmed === '') {
      return null;
    }

    if (maxLength && trimmed.length > maxLength) {
      return trimmed.slice(0, maxLength);
    }

    return trimmed;
  }
}

module.exports = ValidationHelpers;
```

**Usage:**

```javascript
// APIClient.js
const ValidationHelpers = require('../utils/ValidationHelpers');

validateApiKey() {
  const trimmedKey = ValidationHelpers.validateRequiredString(this.apiKey, 'API key');

  if (trimmedKey.length > API_CLIENT_CONFIG.MAX_API_KEY_LENGTH) {
    throw new Error('API key exceeds maximum length (possible paste error)');
  }

  this.apiKey = trimmedKey;
}

validateVideoUrl(url) {
  if (!ValidationHelpers.isNonEmptyString(url)) {
    throw this.createAppError(
      ERROR_TYPES.VALIDATION,
      'Video URL is required and must be non-empty string'
    );
  }

  const MAX_URL_LENGTH = 2083;
  if (url.length > MAX_URL_LENGTH) {
    throw this.createAppError(
      ERROR_TYPES.VALIDATION,
      `Video URL exceeds maximum length (${MAX_URL_LENGTH} characters)`
    );
  }

  const youtubePattern = /^https?:\/\/(www\.)?(youtube\.com|youtu\.be)\//;
  if (!youtubePattern.test(url)) {
    const urlPreview = url.length > 100 ? url.substring(0, 100) + '...' : url;
    throw this.createAppError(
      ERROR_TYPES.VALIDATION,
      'Invalid YouTube URL format',
      { url: urlPreview }
    );
  }
}
```

### Step 4: Apply Guard Clauses to Reduce Nesting

#### A. Guard Clause Strategy

Multiple methods use nested conditionals creating 3-4 levels of nesting. Guard clauses enable early returns, reducing nesting and improving readability. Target methods: calculateRetryDelay, extractVideoIdFromLine, validateVideoId.

#### B. Refactoring Examples

**Nested Conditions:**

```javascript
// Before: calculateRetryDelay (lines 293-315)
calculateRetryDelay(error, attempt) {
  const retryAfterSeconds = this.validateRetryAfter(error.context?.retryAfter);

  if (retryAfterSeconds !== null) {
    if (retryAfterSeconds === 0) {
      console.warn('[API] Server requested immediate retry - applying minimum delay');
      return this.applyJitter(APIClient.RETRY_CONFIG.minDelayMs);
    }

    const delayMs = retryAfterSeconds * 1000;
    console.log(`[API] Using server-provided Retry-After: ${retryAfterSeconds}s`);
    return Math.round(delayMs);
  }

  const baseDelay = Math.round(
    APIClient.RETRY_CONFIG.initialDelayMs *
    Math.pow(APIClient.RETRY_CONFIG.backoffMultiplier, attempt - 1)
  );

  const cappedDelay = Math.min(baseDelay, APIClient.RETRY_CONFIG.maxDelayMs);

  return this.applyJitter(cappedDelay);
}
```

**Guard Clauses:**

```javascript
// After: calculateRetryDelay (reduced nesting)
calculateRetryDelay(error, attempt) {
  const retryAfterSeconds = this.validateRetryAfter(error.context?.retryAfter);

  // Guard: Handle server-provided delay
  if (retryAfterSeconds !== null) {
    return this.useServerProvidedDelay(retryAfterSeconds);
  }

  // Default: Exponential backoff
  return this.calculateExponentialBackoff(attempt);
}

useServerProvidedDelay(retryAfterSeconds) {
  if (retryAfterSeconds === 0) {
    console.warn('[API] Server requested immediate retry - applying minimum delay');
    return this.applyJitter(RETRY_CONFIG.MIN_DELAY_MS);
  }

  const delayMs = retryAfterSeconds * 1000;
  console.log(`[API] Using server-provided Retry-After: ${retryAfterSeconds}s`);
  return Math.round(delayMs);
}

calculateExponentialBackoff(attempt) {
  const baseDelay = Math.round(
    RETRY_CONFIG.INITIAL_DELAY_MS *
    Math.pow(RETRY_CONFIG.BACKOFF_MULTIPLIER, attempt - 1)
  );

  const cappedDelay = Math.min(baseDelay, RETRY_CONFIG.MAX_DELAY_MS);

  return this.applyJitter(cappedDelay);
}
```

**URLParser Nested Validation:**

```javascript
// Before: extractVideoIdFromLine (lines 272-308)
extractVideoIdFromLine(line) {
  const sanitized = this.sanitizeLine(line);

  if (!sanitized) {
    return null;
  }

  if (!this.isValidScheme(sanitized)) {
    console.warn(`[URLParser] Skipping URL with invalid scheme: ${sanitized.substring(0, 100)}`);
    return null;
  }

  for (const pattern of URLParser.YOUTUBE_URL_PATTERNS) {
    let match;

    try {
      match = sanitized.match(pattern);
    } catch (error) {
      console.warn(`[URLParser] Regex error on line: ${error.message}`);
      return null;
    }

    if (match && match[1]) {
      const videoId = match[1];

      if (this.validateVideoId(videoId)) {
        return videoId;
      } else {
        console.warn(`[URLParser] Extracted ID failed validation: ${videoId}`);
        return null;
      }
    }
  }

  console.warn(`[URLParser] Skipping invalid YouTube URL: ${sanitized.substring(0, 100)}`);
  return null;
}
```

**Guard Clauses:**

```javascript
// After: extractVideoIdFromLine (reduced nesting)
extractVideoIdFromLine(line) {
  const sanitized = this.sanitizeLine(line);

  // Guard: Invalid line
  if (!sanitized) {
    return null;
  }

  // Guard: Invalid URL scheme
  if (!this.isValidScheme(sanitized)) {
    console.warn(`[URLParser] Skipping URL with invalid scheme: ${sanitized.substring(0, 100)}`);
    return null;
  }

  // Try each pattern
  return this.matchYoutubePattern(sanitized);
}

matchYoutubePattern(sanitizedUrl) {
  for (const pattern of URLParser.YOUTUBE_URL_PATTERNS) {
    const videoId = this.attemptPatternMatch(pattern, sanitizedUrl);

    if (videoId) {
      return videoId;
    }
  }

  console.warn(`[URLParser] Skipping invalid YouTube URL: ${sanitizedUrl.substring(0, 100)}`);
  return null;
}

attemptPatternMatch(pattern, url) {
  try {
    const match = url.match(pattern);

    if (!match || !match[1]) {
      return null;
    }

    const videoId = match[1];

    if (this.validateVideoId(videoId)) {
      return videoId;
    }

    console.warn(`[URLParser] Extracted ID failed validation: ${videoId}`);
    return null;

  } catch (error) {
    console.warn(`[URLParser] Regex error on line: ${error.message}`);
    return null;
  }
}
```

### Step 5: Rename Unclear Variables

#### A. Naming Improvements Strategy

Multiple variables use abbreviations or unclear names: ms, parsed, trimmed, sanitized, match, stats, seen. Rename to self-documenting names expressing intent and domain concepts.

#### B. Naming Transformations

**Variables:**

```javascript
// Before: Abbreviations and unclear names
async sleepWithCleanup(ms) {
  return new Promise((resolve) => {
    const timeoutId = setTimeout(() => {
      this.activeTimeouts.delete(timeoutId);
      resolve();
    }, ms);

    this.activeTimeouts.add(timeoutId);
  });
}

// After: Descriptive names
async sleepWithCleanup(delayMilliseconds) {
  return new Promise((resolve) => {
    const timeoutId = setTimeout(() => {
      this.activeTimeouts.delete(timeoutId);
      resolve();
    }, delayMilliseconds);

    this.activeTimeouts.add(timeoutId);
  });
}
```

```javascript
// Before: Generic "parsed" variable
validateRetryAfter(retryAfter) {
  if (!retryAfter) return null;

  const parsed = parseInt(retryAfter, 10);

  if (isNaN(parsed) || parsed < 0) {
    console.warn(`[API] Invalid Retry-After header: ${retryAfter}`);
    return null;
  }

  if (parsed > APIClient.RETRY_BUDGET.maxRetryAfterSeconds) {
    console.warn(
      `[API] Retry-After ${parsed}s exceeds maximum ` +
      `${APIClient.RETRY_BUDGET.maxRetryAfterSeconds}s - capping`
    );
    return APIClient.RETRY_BUDGET.maxRetryAfterSeconds;
  }

  return parsed;
}

// After: Intent-revealing name
validateRetryAfter(retryAfter) {
  if (!retryAfter) return null;

  const retryAfterSeconds = parseInt(retryAfter, 10);

  if (isNaN(retryAfterSeconds) || retryAfterSeconds < 0) {
    console.warn(`[API] Invalid Retry-After header: ${retryAfter}`);
    return null;
  }

  if (retryAfterSeconds > RETRY_BUDGET.MAX_RETRY_AFTER_SECONDS) {
    console.warn(
      `[API] Retry-After ${retryAfterSeconds}s exceeds maximum ` +
      `${RETRY_BUDGET.MAX_RETRY_AFTER_SECONDS}s - capping`
    );
    return RETRY_BUDGET.MAX_RETRY_AFTER_SECONDS;
  }

  return retryAfterSeconds;
}
```

```javascript
// Before: URLParser statistics tracking
parseContent(content) {
  const stats = {
    totalLines: 0,
    blankLines: 0,
    commentLines: 0,
    validUrls: 0,
    invalidUrls: 0,
    duplicates: 0
  };

  const seen = new Set();

  // ...
}

// After: Domain-specific naming
parseContent(content) {
  const parsingStatistics = {
    totalLines: 0,
    blankLines: 0,
    commentLines: 0,
    validUrls: 0,
    invalidUrls: 0,
    duplicates: 0
  };

  const processedVideoIds = new Set();

  // ...
}
```

### Step 6: Extract Error Handling Module

#### A. Error Module Rationale

Error creation, transformation, and sanitization logic spans 8 methods (createAppError, sanitizeErrorContext, transformError, handleNetworkError, isTimeoutError, isNetworkError, isRetriableError, isSkippableError). This violates Single Responsibility and makes APIClient harder to understand. Extract to dedicated ErrorHandler class.

#### B. Module Structure

```javascript
// src/utils/ErrorHandler.js
const { ERROR_TYPES } = require('../constants/APIClientConstants');

class ErrorHandler {
  static createApplicationError(type, message, context = {}) {
    const error = new Error(message);
    error.type = type;
    error.context = this.sanitizeContext(context);
    error.isAPIError = true;
    return error;
  }

  static sanitizeContext(context) {
    const sanitized = { ...context };

    if (sanitized.headers) {
      delete sanitized.headers['x-api-key'];
      delete sanitized.headers['authorization'];
    }

    if (sanitized.data) {
      sanitized.data = this.truncateData(sanitized.data, 500);
    }

    return sanitized;
  }

  static truncateData(data, maxLength) {
    if (typeof data === 'string') {
      return data.substring(0, maxLength);
    }

    try {
      const serialized = JSON.stringify(data);
      return serialized.substring(0, maxLength);
    } catch {
      return '[Non-serializable data]';
    }
  }

  static isRetriableError(error) {
    return error.type === ERROR_TYPES.RATE_LIMITED;
  }

  static isSkippableError(error) {
    return [
      ERROR_TYPES.INVALID_REQUEST,
      ERROR_TYPES.SERVER_ERROR,
      ERROR_TYPES.TIMEOUT,
      ERROR_TYPES.NETWORK,
      ERROR_TYPES.VALIDATION,
    ].includes(error.type);
  }
}

module.exports = ErrorHandler;
```

```javascript
// APIClient.js (simplified)
const ErrorHandler = require('../utils/ErrorHandler');

class APIClient {
  createAppError(type, message, context = {}) {
    return ErrorHandler.createApplicationError(type, message, context);
  }

  isRetriableError(error) {
    return ErrorHandler.isRetriableError(error);
  }

  isSkippableError(error) {
    return ErrorHandler.isSkippableError(error);
  }
}
```

### Step 7: Simplify Interceptor Implementations

#### A. Interceptor Complexity Issues

The attachInterceptors method (lines 175-203) creates inline interceptor functions with nested conditionals and optional chaining. Extract interceptor logic into named methods for clarity and testability.

#### B. Refactoring Pattern

**Before: Inline Interceptor Logic**

```javascript
attachInterceptors(client) {
  // Request interceptor - logging only
  client.interceptors.request.use(
    (config) => {
      // SECURITY: Never log API key
      const url = config.url || config.baseURL;
      console.log(`[API] ${config.method?.toUpperCase() || 'REQUEST'} ${url}`);
      return config;
    },
    (error) => {
      const message = error?.message || String(error) || 'Unknown error';
      console.error('[API] Request preparation failed:', message);
      return Promise.reject(error);
    }
  );

  // Response interceptor - error transformation
  client.interceptors.response.use(
    (response) => {
      const url = response.config?.url || response.config?.baseURL || '[unknown]';
      const status = response.status || '[no status]';
      console.log(`[API] Response ${status} from ${url}`);
      return response;
    },
    (error) => {
      return Promise.reject(this.transformError(error));
    }
  );
}
```

**After: Named Interceptor Methods**

```javascript
attachInterceptors(client) {
  client.interceptors.request.use(
    this.handleSuccessfulRequest.bind(this),
    this.handleFailedRequest.bind(this)
  );

  client.interceptors.response.use(
    this.handleSuccessfulResponse.bind(this),
    this.handleFailedResponse.bind(this)
  );
}

handleSuccessfulRequest(config) {
  const requestUrl = config.url || config.baseURL;
  const requestMethod = config.method?.toUpperCase() || 'REQUEST';

  console.log(`[API] ${requestMethod} ${requestUrl}`);

  return config;
}

handleFailedRequest(error) {
  const errorMessage = error?.message || String(error) || 'Unknown error';

  console.error('[API] Request preparation failed:', errorMessage);

  return Promise.reject(error);
}

handleSuccessfulResponse(response) {
  const responseUrl = response.config?.url || response.config?.baseURL || '[unknown]';
  const responseStatus = response.status || '[no status]';

  console.log(`[API] Response ${responseStatus} from ${responseUrl}`);

  return response;
}

handleFailedResponse(error) {
  return Promise.reject(this.transformError(error));
}
```

### Step 8: Consolidate URL/ID Validation Logic

#### A. Validation Consolidation Rationale

URL and video ID validation logic is scattered across validateVideoUrl, extractVideoId, and URLParser methods. Consolidate into a dedicated URLValidator class for reusability and consistency.

#### B. Validator Structure

```javascript
// src/utils/URLValidator.js
class URLValidator {
  static MAX_URL_LENGTH = 2083;
  static VIDEO_ID_LENGTH = 11;
  static VIDEO_ID_PATTERN = /^[a-zA-Z0-9_-]{11}$/;

  static YOUTUBE_URL_PATTERNS = [
    /(?:https?:\/\/)?(?:www\.)?youtube\.com\/watch\?v=([a-zA-Z0-9_-]{11})/,
    /(?:https?:\/\/)?(?:www\.)?youtu\.be\/([a-zA-Z0-9_-]{11})/,
    /(?:https?:\/\/)?(?:www\.)?youtube\.com\/embed\/([a-zA-Z0-9_-]{11})/,
    /(?:https?:\/\/)?(?:www\.)?youtube\.com\/v\/([a-zA-Z0-9_-]{11})/,
  ];

  static validateYouTubeUrl(url) {
    if (!url || typeof url !== 'string' || url.trim() === '') {
      throw new Error('Video URL is required and must be non-empty string');
    }

    if (url.length > this.MAX_URL_LENGTH) {
      throw new Error(`Video URL exceeds maximum length (${this.MAX_URL_LENGTH} characters)`);
    }

    const youtubePattern = /^https?:\/\/(www\.)?(youtube\.com|youtu\.be)\//;
    if (!youtubePattern.test(url)) {
      const urlPreview = url.length > 100 ? url.substring(0, 100) + '...' : url;
      throw new Error(`Invalid YouTube URL format: ${urlPreview}`);
    }
  }

  static extractVideoId(url) {
    for (const pattern of this.YOUTUBE_URL_PATTERNS) {
      const match = url.match(pattern);

      if (match && match[1]) {
        return match[1];
      }
    }

    return url;
  }

  static validateVideoId(videoId) {
    if (!videoId || typeof videoId !== 'string') {
      return false;
    }

    if (videoId.length !== this.VIDEO_ID_LENGTH) {
      return false;
    }

    if (!this.VIDEO_ID_PATTERN.test(videoId)) {
      return false;
    }

    return true;
  }

  static getInvalidReason(videoId) {
    if (!videoId || typeof videoId !== 'string') {
      return 'Video ID is not a string';
    }

    if (videoId.length !== this.VIDEO_ID_LENGTH) {
      return `Invalid length: ${videoId.length} (expected ${this.VIDEO_ID_LENGTH})`;
    }

    if (!this.VIDEO_ID_PATTERN.test(videoId)) {
      return 'Contains invalid characters (only alphanumeric, dash, underscore allowed)';
    }

    return null;
  }
}

module.exports = URLValidator;
```

## Code Quality Patterns

### Single Responsibility

```javascript
// Bad: APIClient handles error creation, validation, HTTP, retry logic
class APIClient {
  fetchTranscript() {}
  validateApiKey() {}
  createAppError() {}
  sanitizeErrorContext() {}
  transformError() {}
  isRetriableError() {}
}

// Good: Focused responsibilities
class APIClient {
  fetchTranscript() {}
  initialize() {}
}

class ErrorHandler {
  static createError() {}
  static transformError() {}
}

class URLValidator {
  static validate() {}
  static extractId() {}
}
```

### Function Length Constraint

```javascript
// Bad: 30+ line methods
async fetchWithRetry(videoUrl, attempt = 1, budgetStartTime = null) {
  // 30 lines of initialization, HTTP call, error handling, retry logic
}

// Good: <15 line focused methods
async fetchWithRetry(videoUrl, attempt = 1, budgetStartTime = null) {
  const startTime = this.initializeRetryTracking(attempt, budgetStartTime);

  try {
    return await this.executeApiRequest(videoUrl);
  } catch (error) {
    return await this.handleRetryOrThrow(error, videoUrl, attempt, startTime);
  }
}
```

### Guard Clauses Over Nesting

```javascript
// Bad: Nested conditionals
if (retryAfterSeconds !== null) {
  if (retryAfterSeconds === 0) {
    return this.applyJitter(minDelay);
  }
  return Math.round(retryAfterSeconds * 1000);
}

// Good: Early returns
if (retryAfterSeconds !== null) {
  return this.useServerProvidedDelay(retryAfterSeconds);
}

return this.calculateExponentialBackoff(attempt);
```

## Validation Checklist

- [ ] All static constants extracted to dedicated constants file
- [ ] No method exceeds 20 lines
- [ ] No nesting depth exceeds 3 levels
- [ ] All variables have descriptive, self-documenting names
- [ ] Duplicate validation logic consolidated into reusable helpers
- [ ] Error handling logic extracted to dedicated ErrorHandler module
- [ ] URL/ID validation consolidated into URLValidator class
- [ ] Interceptor logic extracted to named methods
- [ ] APIClient.js reduced to <500 lines
- [ ] All methods follow Single Responsibility Principle
- [ ] Guard clauses applied throughout
- [ ] Consistent naming conventions across all modules

## Code Smells Catalog

### Identified Smells

**CLEAN-01: Bloater - Large Class**

- Location: APIClient.js (722 lines)
- Issue: Class mixing HTTP communication, error handling, validation, retry logic
- Resolution: Extract ErrorHandler, URLValidator, constants

**CLEAN-02: Bloater - Long Method**

- Location: fetchWithRetry (30 lines), transformError (62 lines), parseContent (63 lines)
- Issue: Methods mixing multiple abstraction levels and responsibilities
- Resolution: Extract helper methods per Step 2

**CLEAN-03: Dispensable - Duplicate Code**

- Location: String validation in validateApiKey, validateVideoUrl, sanitizeLine
- Issue: Repeated null checks, type checks, trimming logic
- Resolution: Extract ValidationHelpers per Step 3

**CLEAN-04: Change Preventer - Complex Conditional**

- Location: calculateRetryDelay, extractVideoIdFromLine, transformError
- Issue: Deep nesting (3-4 levels) reduces readability
- Resolution: Apply guard clauses per Step 4

**CLEAN-05: Dispensable - Poor Naming**

- Location: ms, parsed, trimmed, sanitized, stats, seen
- Issue: Abbreviations and generic names obscure intent
- Resolution: Rename to domain-specific names per Step 5

**CLEAN-06: Object-Orientation Abuser - Switch Statement**

- Location: transformError switch on HTTP status codes
- Issue: Could use object mapping for cleaner structure
- Resolution: Replace switch with errorMap object per Step 2C

**CLEAN-07: Bloater - Static Configuration Clutter**

- Location: Lines 35-75 of APIClient.js
- Issue: 76 lines of constants obscure class logic
- Resolution: Extract to APIClientConstants.js per Step 1

**CLEAN-08: Coupler - Feature Envy**

- Location: APIClient methods operating heavily on error objects
- Issue: Error manipulation logic belongs in dedicated handler
- Resolution: Extract ErrorHandler module per Step 6

## Constraints & Boundaries

**Focus EXCLUSIVELY on:**

- Code readability/clarity
- Naming conventions
- Function/class design
- Code organization
- Duplication elimination
- Complexity reduction

**DO NOT modify:**

- Business logic correctness
- API contracts or response handling
- Error classification (TR-12 specifications)
- Retry strategy (exponential backoff, jitter)
- Security measures (API key sanitization)
- External interfaces (fetchTranscript signature)

## Execution Notes

All refactoring steps preserve external behavior and API contracts. Changes are structural improvements only. After refactoring:

- All existing tests (if any) must pass
- External callers of APIClient.fetchTranscript unaffected
- Error types and context remain unchanged
- Retry behavior identical
- Security properties maintained
