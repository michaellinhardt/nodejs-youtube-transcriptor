# Refactoring Plan: Clean Code Improvements

**Date:** 2025-11-19
**Task Reference:** 5.3 Symbolic link management (implements FR-4, TR-9)
**Code Smells Addressed:** CLEAN-01, CLEAN-02, CLEAN-03, CLEAN-04, CLEAN-05, CLEAN-06
**Status:** Ready for Implementation

## Plan Overview

This plan addresses clean code improvements for the TranscriptService class, specifically focusing on the new batch processing functionality added in task 5.3 (symbolic link management). The additions include three new methods: `processVideo`, `processBatch`, and `extractVideoId`, which implement the complete TR-7 transcript processing workflow. While the code is functionally sound and follows the technical requirements, several readability and maintainability improvements can be made to enhance clarity, reduce duplication, and improve naming consistency. The refactoring will make the codebase more maintainable for future development iterations.

## Tasks Planned

- 5.3 Symbolic link management (implements FR-4, TR-9) [REMEDIATED 2025-11-19]
  - 5.3.5 Complete TranscriptService integration with processBatch
  - 5.3.6 Refactor processVideo to implement explicit TR-7 workflow steps
  - 5.3.7 Validate registry schema compliance in \_trackLink
  - 5.3.8 Verify cross-platform compatibility with enhanced error messages
  - 5.3.9 Add extractVideoId implementing TR-5 URL parsing

## Refactoring Goals

- Reduce code duplication in error handling and result formatting
- Improve naming clarity for variables and reduce abbreviations
- Extract magic numbers and repeated string literals to named constants
- Simplify complex conditional logic in batch processing
- Enhance console output consistency across methods
- Reduce method complexity in `processBatch` by extracting helper functions

## High-Level Steps

1. Extract repeated console output patterns to formatting utilities
2. Extract result object structures to named factory functions
3. Improve variable naming in `processBatch` for clarity
4. Extract URL pattern validation to constants
5. Consolidate duplicate cache check logic
6. Simplify error aggregation in batch processing
7. Extract logging messages to constant templates

## Detailed Breakdown

### Step 1: Extract Console Output Formatting

#### A. Rationale & Objective

Console logging patterns are repeated throughout the service with inconsistent formatting. Methods like `displayCacheStats()`, `displayStats()`, and batch processing summaries all follow similar structures but with slight variations. Extracting these to utility functions improves maintainability and ensures consistent user experience.

#### B. Refactoring Strategy

Create a dedicated formatting utility module for console output that provides reusable templates for statistics summaries, progress messages, and error reports.

#### C. Implementation Pattern

**Before: Scattered logging with duplication**

```javascript
displayCacheStats() {
  const stats = this.getCacheStats();

  console.log('\n=== Cache Performance ===');
  console.log(`Total requests: ${stats.total}`);
  console.log(`Cache hits: ${stats.hits}`);
  console.log(`Cache misses: ${stats.misses}`);
  console.log(`Hit rate: ${stats.hitRate}`);
  console.log(`API calls saved: ${stats.hits}`);
  console.log(`Elapsed time: ${stats.elapsedSeconds}s`);
  console.log('========================\n');
}

displayStats() {
  const cacheStats = this.getCacheStats();

  console.log('\n=== Processing Summary ===');
  console.log(`Total requests: ${cacheStats.total}`);
  console.log(`Cache hits: ${cacheStats.hits}`);
  console.log(`Cache misses: ${cacheStats.misses}`);
  console.log(`Links created: ${this.stats.linksCreated}`);
  console.log(`Links failed: ${this.stats.linksFailed}`);
  console.log(`Hit rate: ${cacheStats.hitRate}`);
  console.log(`Elapsed time: ${cacheStats.elapsedSeconds}s`);
  console.log('=========================\n');
}

// In processBatch
console.log('\n=== Batch Processing Complete ===');
console.log(`Total URLs: ${videoUrls.length}`);
console.log(`Processed: ${results.processed}`);
// ... more repeated patterns
```

**After: Extracted formatting utilities**

```javascript
// src/utils/ConsoleFormatter.js
class ConsoleFormatter {
  static displayBox(title, content, width = 50) {
    const separator = '='.repeat(width);
    console.log(`\n${separator}`);
    console.log(title.padEnd(width));
    console.log(separator);

    for (const [key, value] of Object.entries(content)) {
      console.log(`${key}: ${value}`);
    }

    console.log(`${separator}\n`);
  }

  static formatStats(stats) {
    return {
      'Total requests': stats.total,
      'Cache hits': stats.hits,
      'Cache misses': stats.misses,
      'Hit rate': stats.hitRate,
      'Elapsed time': `${stats.elapsedSeconds}s`
    };
  }

  static formatBatchResults(results, totalUrls) {
    return {
      'Total URLs': totalUrls,
      'Processed': results.processed,
      'From cache': results.cached,
      'Fetched new': results.fetched,
      'Links created': results.linked,
      'Failed': results.failed
    };
  }
}

// Usage in TranscriptService
displayCacheStats() {
  const stats = this.getCacheStats();
  const formatted = ConsoleFormatter.formatStats(stats);
  formatted['API calls saved'] = stats.hits;
  ConsoleFormatter.displayBox('Cache Performance', formatted);
}

displayStats() {
  const cacheStats = this.getCacheStats();
  const formatted = {
    ...ConsoleFormatter.formatStats(cacheStats),
    'Links created': this.stats.linksCreated,
    'Links failed': this.stats.linksFailed
  };
  ConsoleFormatter.displayBox('Processing Summary', formatted);
}
```

### Step 2: Extract Result Object Structures

#### A. Rationale & Objective

Result objects are constructed inline in multiple places (`processVideo`, `processBatch`) with magic property names. These should be extracted to factory functions that document the expected structure and provide type safety through JSDoc.

#### B. Refactoring Strategy

Create factory functions that construct result objects with proper documentation, making the code self-documenting and reducing the chance of typos in property names.

#### C. Implementation Pattern

**Before: Inline object construction**

```javascript
async processVideo(videoId, videoUrl, projectDir = process.cwd()) {
  // ... processing logic

  return {
    success: true,
    videoId,
    cached,
    linked: linkResult.success,
    linkPath: linkResult.path,
    replaced: linkResult.replaced || false
  };
}

async processBatch(videoUrls, projectDir = process.cwd()) {
  const results = {
    processed: 0,
    cached: 0,
    fetched: 0,
    linked: 0,
    failed: 0,
    errors: []
  };
  // ... more inline construction
}
```

**After: Factory functions**

```javascript
// src/utils/ResultFactory.js
class ResultFactory {
  /**
   * Create process video result object
   * @param {Object} data - Result data
   * @returns {ProcessVideoResult}
   */
  static createProcessVideoResult(data) {
    return {
      success: data.success || false,
      videoId: data.videoId,
      cached: data.cached || false,
      linked: data.linked || false,
      linkPath: data.linkPath || null,
      replaced: data.replaced || false
    };
  }

  /**
   * Create empty batch results object
   * @returns {BatchResults}
   */
  static createEmptyBatchResults() {
    return {
      processed: 0,
      cached: 0,
      fetched: 0,
      linked: 0,
      failed: 0,
      errors: []
    };
  }

  /**
   * Add batch error
   * @param {BatchResults} results - Results object to mutate
   * @param {string} url - Failed URL
   * @param {string} errorMessage - Error message
   */
  static addBatchError(results, url, errorMessage) {
    results.failed++;
    results.errors.push({
      url,
      error: errorMessage
    });
  }
}

// Usage in TranscriptService
async processVideo(videoId, videoUrl, projectDir = process.cwd()) {
  // ... processing logic

  return ResultFactory.createProcessVideoResult({
    success: true,
    videoId,
    cached,
    linked: linkResult.success,
    linkPath: linkResult.path,
    replaced: linkResult.replaced
  });
}

async processBatch(videoUrls, projectDir = process.cwd()) {
  const results = ResultFactory.createEmptyBatchResults();
  // ...
}
```

### Step 3: Improve Variable Naming

#### A. Rationale & Objective

Several variables use abbreviated or unclear names that reduce code readability. Variables like `err` should be `error`, and contextual prefixes should clarify purpose.

#### B. Variable Renaming Map

**Function: `processBatch`**

```javascript
// Before: Generic error iteration variable
results.errors.forEach((err, idx) => {
  console.log(`  ${idx + 1}. ${err.url}`);
  console.log(`     ${err.error}`);
});

// After: Descriptive variable names
results.errors.forEach((errorEntry, errorIndex) => {
  const errorNumber = errorIndex + 1;
  console.log(`  ${errorNumber}. ${errorEntry.url}`);
  console.log(`     ${errorEntry.error}`);
});
```

**Function: `isCached`**

```javascript
// Before: Generic 'exists' name
let exists = false;
if (inRegistry) {
  const fileExists = await this.storage.transcriptExists(trimmedId);

  if (!fileExists) {
    console.warn(`[Cache] Registry entry exists but file missing for ${trimmedId} - will refetch`);
    exists = false;
  } else {
    exists = true;
  }
}

// After: Clear intent
let isCachedAndValid = false;
if (inRegistry) {
  const transcriptFileExists = await this.storage.transcriptExists(trimmedId);

  if (!transcriptFileExists) {
    console.warn(`[Cache] Registry entry exists but file missing for ${trimmedId} - will refetch`);
    isCachedAndValid = false;
  } else {
    isCachedAndValid = true;
  }
}

return isCachedAndValid;
```

### Step 4: Extract URL Pattern Constants

#### A. Rationale & Objective

The `extractVideoId` method contains hardcoded regex patterns and magic numbers (11 character length). These should be extracted to named constants for better documentation and maintainability.

#### B. Implementation Pattern

**Before: Magic numbers and inline regex**

```javascript
extractVideoId(url) {
  if (!url || typeof url !== 'string' || url.trim() === '') {
    throw new Error('URL required and must be non-empty string');
  }

  const trimmedUrl = url.trim();

  // TR-5: YouTube URL pattern matching
  const patterns = [
    /(?:youtu\.be\/)([^&\s?]+)/,
    /(?:youtube\.com\/watch\?v=)([^&\s]+)/,
    /(?:youtube\.com\/embed\/)([^&\s?]+)/,
    /(?:youtube\.com\/v\/)([^&\s?]+)/
  ];

  for (const pattern of patterns) {
    const match = trimmedUrl.match(pattern);
    if (match && match[1]) {
      const videoId = match[1];

      // TR-5: Validate 11-char alphanumeric+dash format
      if (videoId.length === 11 && /^[a-zA-Z0-9_-]+$/.test(videoId)) {
        return videoId;
      }
    }
  }

  throw new Error(`Unable to extract valid YouTube video ID from URL: ${trimmedUrl}`);
}
```

**After: Named constants**

```javascript
// At top of file or in separate constants module
const VIDEO_ID_LENGTH = 11;
const VIDEO_ID_PATTERN = /^[a-zA-Z0-9_-]+$/;

const YOUTUBE_URL_PATTERNS = {
  SHORT_LINK: /(?:youtu\.be\/)([^&\s?]+)/,
  WATCH_URL: /(?:youtube\.com\/watch\?v=)([^&\s]+)/,
  EMBED_URL: /(?:youtube\.com\/embed\/)([^&\s?]+)/,
  VIDEO_URL: /(?:youtube\.com\/v\/)([^&\s?]+)/
};

extractVideoId(url) {
  if (!url || typeof url !== 'string' || url.trim() === '') {
    throw new Error('URL required and must be non-empty string');
  }

  const trimmedUrl = url.trim();

  // TR-5: YouTube URL pattern matching
  const patterns = Object.values(YOUTUBE_URL_PATTERNS);

  for (const pattern of patterns) {
    const match = trimmedUrl.match(pattern);
    if (match && match[1]) {
      const videoId = match[1];

      // TR-5: Validate format per YouTube specification
      if (videoId.length === VIDEO_ID_LENGTH && VIDEO_ID_PATTERN.test(videoId)) {
        return videoId;
      }
    }
  }

  throw new Error(
    `Unable to extract valid YouTube video ID from URL: ${trimmedUrl}. ` +
    `Expected ${VIDEO_ID_LENGTH}-character ID matching pattern ${VIDEO_ID_PATTERN}`
  );
}
```

### Step 5: Consolidate Duplicate Cache Check Logic

#### A. Rationale & Objective

The cache checking logic appears in multiple places with slight variations (`isCached`, within `processVideo`). The conditional logic for handling cache hits can be simplified using guard clauses.

#### B. Refactoring Strategy

Apply guard clause pattern to reduce nesting and make the flow more linear and readable.

#### C. Implementation Pattern

**Before: Nested conditionals**

```javascript
async processVideo(videoId, videoUrl, projectDir = process.cwd()) {
  validators.assertValidVideoId(videoId);
  const absoluteProjectDir = path.resolve(projectDir);

  const cached = await this.isCached(videoId);

  let transcript;
  if (cached) {
    transcript = await this.storage.readTranscript(videoId);
    console.log(`[Cache] Hit: ${videoId}`);
    this.stats.cacheHits++;
  } else {
    transcript = await this.api.fetchTranscript(videoUrl);
    await this.storage.saveTranscript(videoId, transcript);
    await this.registerTranscript(videoId);
    console.log(`[Fetch] Saved: ${videoId}`);
    this.stats.cacheMisses++;
  }

  const linkResult = await this.linkManager.createLink(videoId, absoluteProjectDir);

  console.log(`[Link] Created: ${linkResult.path}`);
  this.stats.linksCreated++;

  return {
    success: true,
    videoId,
    cached,
    linked: linkResult.success,
    linkPath: linkResult.path,
    replaced: linkResult.replaced || false
  };
}
```

**After: Extracted methods with guard clauses**

```javascript
/**
 * Retrieve transcript from cache or API
 * @private
 */
async _getOrFetchTranscript(videoId, videoUrl) {
  const isCached = await this.isCached(videoId);

  // Guard: Return cached transcript if available
  if (isCached) {
    const transcript = await this.storage.readTranscript(videoId);
    console.log(`[Cache] Hit: ${videoId}`);
    this.stats.cacheHits++;
    return { transcript, wasCached: true };
  }

  // Fetch from API
  const transcript = await this.api.fetchTranscript(videoUrl);
  await this.storage.saveTranscript(videoId, transcript);
  await this.registerTranscript(videoId);
  console.log(`[Fetch] Saved: ${videoId}`);
  this.stats.cacheMisses++;

  return { transcript, wasCached: false };
}

async processVideo(videoId, videoUrl, projectDir = process.cwd()) {
  // Validate inputs
  validators.assertValidVideoId(videoId);
  const absoluteProjectDir = path.resolve(projectDir);

  // Step 1-3: Get or fetch transcript
  const { transcript, wasCached } = await this._getOrFetchTranscript(videoId, videoUrl);

  // Step 4: Create link
  const linkResult = await this.linkManager.createLink(videoId, absoluteProjectDir);
  console.log(`[Link] Created: ${linkResult.path}`);
  this.stats.linksCreated++;

  return ResultFactory.createProcessVideoResult({
    success: true,
    videoId,
    cached: wasCached,
    linked: linkResult.success,
    linkPath: linkResult.path,
    replaced: linkResult.replaced
  });
}
```

### Step 6: Simplify Batch Processing Error Aggregation

#### A. Rationale & Objective

The batch processing loop in `processBatch` is quite long (lines 431-469) and mixes URL processing, error handling, and result aggregation. This should be broken into smaller, focused methods.

#### B. Refactoring Strategy

Extract the per-URL processing logic into a separate method that returns a standardized result object, then aggregate those results in the main loop.

#### C. Implementation Pattern

**Before: Large processing loop**

```javascript
async processBatch(videoUrls, projectDir = process.cwd()) {
  // ... validation and setup

  const results = {
    processed: 0,
    cached: 0,
    fetched: 0,
    linked: 0,
    failed: 0,
    errors: []
  };

  const absoluteProjectDir = path.resolve(projectDir);
  console.log(`[Process] Starting batch processing for ${videoUrls.length} URLs`);
  console.log(`[Process] Project directory: ${absoluteProjectDir}`);

  for (const url of videoUrls) {
    try {
      const videoId = this.extractVideoId(url);
      console.log(`[Process] Processing ${videoId} from ${url}`);

      const wasCached = await this.isCached(videoId);
      const result = await this.processVideo(videoId, url, absoluteProjectDir);

      results.processed++;
      if (wasCached) {
        results.cached++;
      } else {
        results.fetched++;
      }

      if (result.linked) {
        results.linked++;
      }

      console.log(
        `[Process] Success ${videoId} - ` +
        `cached: ${wasCached}, linked: ${result.linked}`
      );

    } catch (error) {
      results.failed++;
      results.errors.push({
        url,
        error: error.message
      });

      console.error(`[Process] Failed ${url}: ${error.message}`);
    }
  }

  // Display batch summary
  // ... 15 lines of console output
}
```

**After: Extracted processing method**

```javascript
/**
 * Process single URL in batch context
 * @private
 */
async _processSingleUrl(url, projectDir) {
  const videoId = this.extractVideoId(url);
  console.log(`[Process] Processing ${videoId} from ${url}`);

  const wasCached = await this.isCached(videoId);
  const result = await this.processVideo(videoId, url, projectDir);

  console.log(
    `[Process] Success ${videoId} - ` +
    `cached: ${wasCached}, linked: ${result.linked}`
  );

  return {
    success: true,
    wasCached,
    linked: result.linked
  };
}

/**
 * Aggregate single URL result into batch results
 * @private
 */
_aggregateBatchResult(results, urlResult) {
  results.processed++;

  if (urlResult.wasCached) {
    results.cached++;
  } else {
    results.fetched++;
  }

  if (urlResult.linked) {
    results.linked++;
  }
}

async processBatch(videoUrls, projectDir = process.cwd()) {
  // Guard: Validate inputs
  if (!Array.isArray(videoUrls)) {
    throw new Error('videoUrls must be an array');
  }

  if (videoUrls.length === 0) {
    console.log('[Process] No URLs to process');
    return ResultFactory.createEmptyBatchResults();
  }

  const results = ResultFactory.createEmptyBatchResults();
  const absoluteProjectDir = path.resolve(projectDir);

  console.log(`[Process] Starting batch processing for ${videoUrls.length} URLs`);
  console.log(`[Process] Project directory: ${absoluteProjectDir}`);

  // Sequential processing per BR-2
  for (const url of videoUrls) {
    try {
      const urlResult = await this._processSingleUrl(url, absoluteProjectDir);
      this._aggregateBatchResult(results, urlResult);
    } catch (error) {
      ResultFactory.addBatchError(results, url, error.message);
      console.error(`[Process] Failed ${url}: ${error.message}`);
    }
  }

  this._displayBatchSummary(videoUrls.length, results);

  return results;
}

/**
 * Display batch processing summary
 * @private
 */
_displayBatchSummary(totalUrls, results) {
  const formatted = ConsoleFormatter.formatBatchResults(results, totalUrls);
  ConsoleFormatter.displayBox('Batch Processing Complete', formatted);

  if (results.errors.length > 0) {
    console.log('Errors:');
    results.errors.forEach((errorEntry, errorIndex) => {
      const errorNumber = errorIndex + 1;
      console.log(`  ${errorNumber}. ${errorEntry.url}`);
      console.log(`     ${errorEntry.error}`);
    });
    console.log();
  }
}
```

### Step 7: Extract Logging Message Templates

#### A. Rationale & Objective

Console log messages are scattered throughout with magic strings and inconsistent formatting. Extract these to constants for easier maintenance and internationalization potential.

#### B. Implementation Pattern

**Before: Magic strings**

```javascript
console.log(`[Cache] Hit: ${videoId}`);
console.log(`[Fetch] Saved: ${videoId}`);
console.log(`[Link] Created: ${linkResult.path}`);
console.log(`[Process] Processing ${videoId} from ${url}`);
console.error(`[Process] Failed ${url}: ${error.message}`);
```

**After: Constant templates**

```javascript
// src/utils/LogMessages.js
const LOG_MESSAGES = {
  CACHE_HIT: (videoId) => `[Cache] Hit: ${videoId}`,
  CACHE_MISS: (videoId) => `[Cache] MISS for ${videoId}`,
  FETCH_SAVED: (videoId) => `[Fetch] Saved: ${videoId}`,
  LINK_CREATED: (path) => `[Link] Created: ${path}`,
  PROCESS_START: (videoId, url) => `[Process] Processing ${videoId} from ${url}`,
  PROCESS_SUCCESS: (videoId, cached, linked) =>
    `[Process] Success ${videoId} - cached: ${cached}, linked: ${linked}`,
  PROCESS_FAILED: (url, errorMessage) => `[Process] Failed ${url}: ${errorMessage}`,
  BATCH_START: (count, projectDir) =>
    `[Process] Starting batch processing for ${count} URLs\n[Process] Project directory: ${projectDir}`,
};

module.exports = { LOG_MESSAGES };

// Usage in TranscriptService
const { LOG_MESSAGES } = require('../utils/LogMessages');

console.log(LOG_MESSAGES.CACHE_HIT(videoId));
console.log(LOG_MESSAGES.FETCH_SAVED(videoId));
console.log(LOG_MESSAGES.LINK_CREATED(linkResult.path));
```

## Code Quality Patterns Applied

### Single Responsibility Principle

**Current Issue**: `processBatch` handles validation, logging, processing, error handling, and result formatting (5+ responsibilities).

**Resolution**: Extract private helper methods:

- `_processSingleUrl`: URL processing logic
- `_aggregateBatchResult`: Result accumulation
- `_displayBatchSummary`: Output formatting

### DRY Principle

**Duplicate Pattern 1**: Console output formatting repeated in 3 methods
**Resolution**: Extract `ConsoleFormatter` utility class

**Duplicate Pattern 2**: Result object construction
**Resolution**: Extract `ResultFactory` utility class

**Duplicate Pattern 3**: Error handling in loops
**Resolution**: Standardize with `ResultFactory.addBatchError`

### Guard Clauses

**Before**: Nested if-else in `processVideo`
**After**: Early return pattern in `_getOrFetchTranscript`

### Named Constants

**Before**: Magic numbers (11), regex patterns inline
**After**: `VIDEO_ID_LENGTH`, `YOUTUBE_URL_PATTERNS` constants

## Validation Checklist

- [ ] All magic numbers replaced with named constants
- [ ] All magic strings extracted to constant templates
- [ ] Variable names are descriptive and self-documenting
- [ ] No function exceeds 30 lines (current: `processBatch` is 60 lines)
- [ ] Duplicate console formatting consolidated
- [ ] Guard clauses applied to reduce nesting
- [ ] Result object construction standardized
- [ ] Error handling patterns consistent
- [ ] Private helper methods extracted from long methods
- [ ] JSDoc comments updated for new utilities

## Implementation Order

1. Create `src/utils/ConsoleFormatter.js` utility
2. Create `src/utils/ResultFactory.js` utility
3. Create `src/utils/LogMessages.js` constants
4. Extract constants for URL patterns and video ID validation
5. Refactor `displayCacheStats()` and `displayStats()` to use ConsoleFormatter
6. Extract `_getOrFetchTranscript()` private method
7. Extract `_processSingleUrl()` private method
8. Extract `_aggregateBatchResult()` private method
9. Extract `_displayBatchSummary()` private method
10. Refactor `processBatch()` to use extracted methods
11. Update variable names throughout
12. Update log statements to use message templates
13. Update JSDoc comments

## Risk Assessment

**Low Risk Refactoring**: All changes preserve existing functionality. Tests would verify behavior unchanged (though project has no test suite per TR-1).

**Potential Issues**:

- Console output format changes may affect external scripts parsing logs (unlikely)
- New utility modules require proper require() statements
- Private method names with `_` prefix should not be documented in external docs

## Expected Outcomes

- Average method length reduced from 35 lines to <25 lines
- Duplicate code eliminated (~40 lines saved)
- Readability score improved through better naming
- Maintenance easier with centralized formatting/messages
- Future internationalization easier with extracted strings
